diff --git a/.gitignore b/.gitignore
index 330ec13..dcc7292 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,3 +1,37 @@
+
+# /
 /_build
 /_dist
 /eclipse-bin
+
+# /bin/
+/bin/panels
+/bin/customActions
+
+# /doc/
+/doc/izpack
+
+# /lib/
+/lib/compiler.jar
+/lib/installer.jar
+/lib/izevent.jar
+/lib/standalone-compiler.jar
+/lib/uninstaller-ext.jar
+/lib/uninstaller.jar
+
+# /src/dist-files/
+/src/dist-files/.xvpics
+
+# /src/native/COIOSHelper/src/
+/src/native/COIOSHelper/src/Release
+
+# /src/native/ShellLink/
+/src/native/ShellLink/ShellLink.vcproj.BISSOLDOM.blf.user
+
+# /src/native/ShellLink/src/
+/src/native/ShellLink/src/Release
+
+# /utils/
+#
+#
+*.class
diff --git a/src/build.xml b/src/build.xml
index 60e52dc..b29e756 100644
--- a/src/build.xml
+++ b/src/build.xml
@@ -572,7 +572,6 @@
             <!-- sourcepath is cleared so there's no mistaking what goes into the Panel -->
             <javac srcdir="@{srcdir}"
                    destdir="${bin.dir}/panels/@{name}"
-                   classpath="${installer.jar}"
                    sourcepath=""
                    optimize="on"
                    deprecation="on"
@@ -581,6 +580,12 @@
                    target="${compat.target}"
                    debuglevel="${debuglevel}">
                 <panel-fileset/>
+				<classpath> 
+					<pathelement location="${installer.jar}"/> 
+					<pathelement location="${basedir}/tigaseLib/tigase-server.jar"/> 
+					<pathelement location="${basedir}/tigaseLib/tigase-utils.jar"/> 
+					<pathelement location="${basedir}/tigaseLib/tigase-xmltools.jar"/> 
+				</classpath> 
             </javac>
             <jar jarfile="${bin.dir}/panels/@{name}.jar" basedir="${bin.dir}/panels/@{name}"/>
         </sequential>
@@ -611,7 +616,9 @@
         </build-panel>
         <build-panel name="CheckedHelloPanel">
             <include name="com/izforge/izpack/panels/CheckedHelloPanel.java"/>
+	        <include name="com/izforge/izpack/panels/CheckedHelloPanelConsoleHelper.java"/>
             <include name="com/izforge/izpack/panels/HelloPanel.java"/>
+	        <include name="com/izforge/izpack/panels/HelloPanelConsoleHelper.java"/>
             <include name="com/izforge/izpack/util/os/*RegistryHandler.java"/>
             <include name="com/izforge/izpack/util/OSClassHelper.java"/>
             <include name="com/izforge/izpack/util/os/WrappedNativeLibException.java"/>
@@ -642,6 +649,7 @@
             <include name="com/izforge/izpack/panels/PacksModel.java"/>
             <include name="com/izforge/izpack/panels/PacksPanel.java"/>
             <include name="com/izforge/izpack/panels/PacksPanelAutomationHelper.java"/>
+	        <include name="com/izforge/izpack/panels/PacksPanelConsoleHelper.java"/>
             <include name="com/izforge/izpack/panels/PacksPanelBase.java"/>
             <include name="com/izforge/izpack/panels/PacksPanelInterface.java"/>
         </build-panel>
@@ -655,12 +663,15 @@
         </build-panel>
         <build-panel name="HTMLLicencePanel">
             <include name="com/izforge/izpack/panels/HTMLLicencePanel.java"/>
+	        <include name="com/izforge/izpack/panels/HTMLLicencePanelConsoleHelper.java"/>
         </build-panel>
         <build-panel name="HTMLInfoPanel">
             <include name="com/izforge/izpack/panels/HTMLInfoPanel.java"/>
+	        <include name="com/izforge/izpack/panels/HTMLInfoPanelConsoleHelper.java"/>
         </build-panel>
         <build-panel name="TargetPanel">
             <include name="com/izforge/izpack/panels/PathInputPanel.java"/>
+	        <include name="com/izforge/izpack/panels/PathInputPanelConsoleHelper.java"/>
             <include name="com/izforge/izpack/panels/PathSelectionPanel.java"/>
             <include name="com/izforge/izpack/panels/TargetPanel.java"/>
             <include name="com/izforge/izpack/panels/TargetPanelAutomationHelper.java"/>
@@ -674,7 +685,9 @@
         </build-panel>
         <build-panel name="JDKPathPanel">
             <include name="com/izforge/izpack/panels/JDKPathPanel.java"/>
+	        <include name="com/izforge/izpack/panels/JDKPathPanelConsoleHelper.java"/>
             <include name="com/izforge/izpack/panels/PathInputPanel.java"/>
+	        <include name="com/izforge/izpack/panels/PathInputPanelConsoleHelper.java"/>
             <include name="com/izforge/izpack/panels/PathSelectionPanel.java"/>
             <include name="com/izforge/izpack/util/os/*RegistryHandler.java"/>
             <include name="com/izforge/izpack/util/OSClassHelper.java"/>
@@ -684,6 +697,22 @@
             <include name="com/coi/tools/os/izpack/Registry.java"/>
             <include name="com/coi/tools/os/izpack/COIOSHelper.java"/>
         </build-panel>
+	 <build-panel name="TigaseJDKPathPanel">
+            <include name="com/izforge/izpack/panels/TigaseJDKPathPanel.java"/>
+	    <include name="com/izforge/izpack/panels/TigaseJDKPathPanelConsoleHelper.java"/>
+	    <include name="com/izforge/izpack/panels/JDKPathPanelConsoleHelper.java"/>
+            <include name="com/izforge/izpack/panels/PathInputPanel.java"/>
+	    <include name="com/izforge/izpack/panels/PathInputPanelConsoleHelper.java"/>
+            <include name="com/izforge/izpack/panels/PathSelectionPanel.java"/>
+            <include name="com/izforge/izpack/panels/TigaseInstallerCommon.java"/>		
+            <include name="com/izforge/izpack/util/os/*RegistryHandler.java"/>
+            <include name="com/izforge/izpack/util/OSClassHelper.java"/>
+            <include name="com/izforge/izpack/util/os/WrappedNativeLibException.java"/>
+            <include name="com/coi/tools/os/win/*.java"/>
+            <include name="com/coi/tools/os/win/resources/NativeLibErr*.java"/>
+            <include name="com/coi/tools/os/izpack/Registry.java"/>
+            <include name="com/coi/tools/os/izpack/COIOSHelper.java"/>
+        </build-panel>
         <build-panel name="XInfoPanel">
             <include name="com/izforge/izpack/panels/XInfoPanel.java"/>
         </build-panel>
@@ -776,6 +805,40 @@
             <include name="com/izforge/izpack/panels/HTMLHelloPanel.java"/>
             <include name="com/izforge/izpack/panels/HTMLInfoPanel.java"/>
         </build-panel>
+
+        <!-- tigase panels -->
+        <build-panel name="DerbyPathPanel">
+            <include name="com/izforge/izpack/panels/DerbyPathPanel.java"/>
+             <include name="com/izforge/izpack/panels/TigaseInstallerCommon.java"/>		
+	     <include name="com/izforge/izpack/panels/DerbyPathPanelConsoleHelper.java"/>
+           <include name="com/izforge/izpack/panels/TigaseConfigConst.java"/>
+             <include name="com/izforge/izpack/panels/TargetPanel.java"/>
+           <include name="com/izforge/izpack/panels/TargetPanelAutomationHelper.java"/>
+            <include name="com/izforge/izpack/panels/PathInputPanel.java"/>
+        </build-panel>
+
+        <build-panel name="TigaseConfigLoadPanel">
+            <include name="com/izforge/izpack/panels/TigaseConfigLoadPanel.java"/>
+              <include name="com/izforge/izpack/panels/TigaseInstallerCommon.java"/>		
+		<include name="com/izforge/izpack/panels/TigaseConfigLoadPanelConsoleHelper.java"/>
+          <include name="com/izforge/izpack/panels/TigaseConfigConst.java"/>
+        </build-panel>
+
+        <build-panel name="TigaseConfigSavePanel">
+            <include name="com/izforge/izpack/panels/TigaseConfigSavePanel.java"/>
+               <include name="com/izforge/izpack/panels/TigaseInstallerCommon.java"/>		
+		<include name="com/izforge/izpack/panels/TigaseConfigSavePanelConsoleHelper.java"/>
+         <include name="com/izforge/izpack/panels/TigaseConfigConst.java"/>
+        </build-panel>
+
+        <build-panel name="TigaseDBCheckPanel">
+            <include name="com/izforge/izpack/panels/TigaseDBCheckPanel.java"/>
+                <include name="com/izforge/izpack/panels/TigaseInstallerCommon.java"/>		
+		<include name="com/izforge/izpack/panels/TigaseDBCheckPanelConsoleHelper.java"/>
+        <include name="com/izforge/izpack/panels/TigaseConfigConst.java"/>
+		<include name="com/izforge/izpack/panels/TigaseInstallerDBHelper.java"/>
+        </build-panel>
+
     </target>
 
     <!--
@@ -811,6 +874,7 @@
             <fileset dir="${build.dir}">
                 <include name="com/izforge/izpack/event/*.class"/>
                 <include name="com/izforge/izpack/util/IoHelper.class"/>
+<!--                <exclude name="com/izforge/izpack/event/*Compiler*.class"/> -->
             </fileset>
         </jar>
     </target>
@@ -1251,7 +1315,7 @@
 
     <!-- Makes everything, from compilation, customer and javadoc to generating an installer. -->
     <target name="dist"
-            depends="src.tar.gz, all, create.docu, generate.installer"
+            depends="src.tar.gz, all, generate.installer"
             description="makes a complete installer"/>
 
     <!-- Makes everything, from Cleaning to generating both installers: normal and reg support. -->
diff --git a/src/lib/com/izforge/izpack/installer/ConsoleHelper.java b/src/lib/com/izforge/izpack/installer/ConsoleHelper.java
new file mode 100644
index 0000000..6a40663
--- /dev/null
+++ b/src/lib/com/izforge/izpack/installer/ConsoleHelper.java
@@ -0,0 +1,172 @@
+package com.izforge.izpack.installer;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+
+public class ConsoleHelper 
+{
+	public void readEnter() 
+	throws IOException 
+	{
+		systemInAsReader().readLine();
+	}
+	
+	public void displayAndBlock(String msg) 
+	throws IOException 
+	{
+		System.out.println(msg);
+		readEnter();
+	}
+	
+	
+	private BufferedReader reader = null;
+	public BufferedReader systemInAsReader() 
+	{
+		if (reader == null)
+		{
+			reader = new BufferedReader(
+					new InputStreamReader(System.in));
+		}
+		return reader;
+	}
+
+	public void displayLabel(String label) {
+		System.out.println(label);
+	}
+	
+	public void displayPrompt(String prompt) {
+		
+		// cut : or :SPACE suffix
+		String[] suffixesToCut = { ":", ": " };
+		String newPrompt = prompt;
+		for (String suffix : suffixesToCut) {
+			if (newPrompt.endsWith(suffix)) 
+			{
+				int endIndex = newPrompt.length()-suffix.length();
+				newPrompt = newPrompt.substring(0, endIndex);
+			}
+		}
+		
+		System.out.print(newPrompt + ": ");
+	}
+
+	public <T> T readUntilValid(
+			String prompt, 
+			ValidatingConverter<String, T> converter) 
+	throws IOException 
+	{
+		BufferedReader sysIn = systemInAsReader(); 
+		
+		T result = null;
+		do 
+		{
+			displayPrompt(prompt);
+			String line = sysIn.readLine();
+			Option<T> validationResult = 
+				converter.convert(line);
+			if (validationResult.isDefined) 
+			{
+				result = validationResult.value;
+			} else {
+				String errorMsg = validationResult.msg;
+				displayLabel(errorMsg);
+			}
+			
+		} while (result == null);
+		
+		return result;
+		
+	}
+
+	public int chooseAction(String... actions) 
+	throws IOException {
+		final int numberOfActions = actions.length;
+		if (numberOfActions < 2) {
+			throw new IllegalArgumentException("Invalid number of " +
+					"actions to choose from");
+		}
+		
+		for (int i = 0 ; i < numberOfActions ; i++) {
+			displayLabel( (i+1) + ".  " + actions[i]);
+		}
+		
+		String prompt = "Choose number (1-" + numberOfActions + ")";
+		return readUntilValid(prompt, new ValidatingConverter<String, Integer>() {
+			public Option<Integer> convert(String from) {
+				int number = 0;
+				try {
+					number = Integer.parseInt(from);
+				} catch (NumberFormatException nfe)  {
+					return Option.empty("Illegal number");
+				}
+				
+				if (number < 1 || number > numberOfActions) {
+					return Option.empty("Choice not in range");
+				}
+				
+				return Option.full(number);
+			}
+		});
+	}
+
+	public void displayEmptyLine() {
+		System.out.println();
+		
+	}
+
+	private interface IPasswordReader {
+		String getPassword(String prompt) throws IOException;
+	}
+	private IPasswordReader passwordReader = null;
+
+	private IPasswordReader getPasswordReader() 
+	{
+		if (passwordReader == null)  // create only once
+		{
+// doesn't seem to work for me anyway :/
+//			if (System.console() != null) 
+//			{
+//				// java 6 passwords support
+//				passwordReader = new IPasswordReader() 
+//				{
+//					public String getPassword(String prompt) throws IOException 
+//					{
+//						displayPrompt(prompt);
+//						char[] pwd = System.console().readPassword(); 
+//						return pwd == null ? null : pwd.toString();
+//					}
+//				};
+//			} 
+//			else 
+//			{
+				// fall back to display password on console :(
+				passwordReader = new IPasswordReader() 
+				{
+					public String getPassword(String prompt) throws IOException 
+					{
+						System.out.println("WARNING: password will be visible while entering");
+						displayPrompt(prompt);
+						return systemInAsReader().readLine();
+					}
+				};
+//			}
+		}
+		return passwordReader;
+	}
+	
+	public String askForPassword(String prompt) 
+	throws IOException 
+	{
+		return getPasswordReader().getPassword(prompt);
+	}
+
+	public void displayMessage(String msg) {
+		System.out.println(msg);
+	}
+
+	public void displayRaw(String msg) {
+		System.out.print(msg);
+	}	
+	
+}
\ No newline at end of file
diff --git a/src/lib/com/izforge/izpack/installer/ConsoleInstallHelper.java b/src/lib/com/izforge/izpack/installer/ConsoleInstallHelper.java
new file mode 100644
index 0000000..e9284c1
--- /dev/null
+++ b/src/lib/com/izforge/izpack/installer/ConsoleInstallHelper.java
@@ -0,0 +1,55 @@
+package com.izforge.izpack.installer;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.List;
+
+
+public class ConsoleInstallHelper {
+	// helpers
+	public final ConsoleHelper console = new ConsoleHelper();
+	public final IOHelper io = new IOHelper();
+	public final ResourceHelper resource = new ResourceHelper();
+	public final ConsolePager pager = new ConsolePager();
+	public final HTMLHelper html = new HTMLHelper();
+	public final VariablesHelper variables = new VariablesHelper();
+	
+	// singleton, use getInstance
+	public static ConsoleInstallHelper getInstance() { return instance; }
+	private ConsoleInstallHelper() {}
+	private static final ConsoleInstallHelper instance = new ConsoleInstallHelper();
+		
+}
+
+
+class IOHelper {
+	
+	public String readAll(BufferedReader reader) 
+	throws IOException 
+	{
+		StringBuilder builder = new StringBuilder();
+		
+		String line = "";
+		do 
+		{
+			line = reader.readLine();
+			if (line != null) 
+			{
+				builder.append(line);
+				builder.append("\n");
+			}
+		} while (line != null);
+		
+		return builder.toString();
+	}
+	
+}
+
+
+class TextHelper {
+	List<String> convertToLines(String stringWithNewlines) {
+		String[] lines = stringWithNewlines.split("\n");
+		return Arrays.asList(lines);
+	}
+}
diff --git a/src/lib/com/izforge/izpack/installer/ConsoleMenu.java b/src/lib/com/izforge/izpack/installer/ConsoleMenu.java
new file mode 100644
index 0000000..da3246c
--- /dev/null
+++ b/src/lib/com/izforge/izpack/installer/ConsoleMenu.java
@@ -0,0 +1,116 @@
+package com.izforge.izpack.installer;
+
+import java.io.IOException;
+import java.util.List;
+
+
+public abstract class ConsoleMenu {
+	private final ConsoleHelper console;
+	private boolean done = false;
+	
+	public ConsoleMenu(ConsoleHelper console) {
+		this.console = console;
+	}
+
+	public void run() 
+	throws IOException 
+	{
+		while (isDone() == false) 
+		{
+			displayMenu();			
+			console.displayEmptyLine();
+			console.displayPrompt("Choose action");
+			String userChoice = console.systemInAsReader().readLine();
+			runAction(userChoice);
+		}
+	}
+
+	public boolean isDone() {
+		return done;
+	}
+
+	protected abstract List<IConsoleMenuItem> getMenuItems();
+	protected abstract String getHeader();
+
+	private IConsoleMenuItem redisplayMenuItem = new IConsoleMenuItem() {
+		public String renderToString() {
+			return "Redisplay menu";
+		}
+		public void runAction() {
+			displayMenu();
+		}
+	};
+
+	private IConsoleMenuItem doneMenuItem = new IConsoleMenuItem() {
+		public String renderToString() {
+			return "Done";
+		}
+		public void runAction() {
+			done = true;
+		}
+	};
+
+	private IConsoleMenuItem invalidActionMenuItem = new IConsoleMenuItem() {
+		public String renderToString() {
+			return "ZONK !!"; // shouldn't be called
+		}
+		public void runAction() {
+			console.displayLabel("Invalid command");
+		}
+	};
+
+
+	private void displayItem(IConsoleMenuItem item, String prefix) {
+		String itemStr = item.renderToString();
+		console.displayLabel(prefix + " => " + itemStr);
+	}
+	
+	private void displayMenu() {
+		List<IConsoleMenuItem> items = getMenuItems();
+		console.displayLabel("------");
+		console.displayLabel(getHeader());
+		console.displayEmptyLine();
+		
+		for (int i = 0 ; i < items.size() ; i++) {
+			IConsoleMenuItem item = items.get(i);
+			displayItem(item, "" + (i+1));
+		}
+		displayItem(redisplayMenuItem, "r");
+		displayItem(doneMenuItem, "d");
+	}
+
+	void runAction(String cmd) {
+		
+		List<? extends IConsoleMenuItem> menuItems = getMenuItems();
+
+		int nmbOfItems = menuItems.size();
+		int nmb = 0;
+		try {
+			nmb = Integer.parseInt(cmd);
+		}
+		catch (NumberFormatException nfe) {
+			nmb = -1;
+		}
+
+		IConsoleMenuItem chosenAction = null;
+		if (nmb >= 1 && nmb <= nmbOfItems) 
+		{
+			chosenAction = menuItems.get(nmb-1);
+		} 
+		else if ("r".equals(cmd)) 
+		{
+			chosenAction = redisplayMenuItem;
+		} 
+		else if ("d".equals(cmd)) 
+		{
+			chosenAction = doneMenuItem;
+		} else 
+		{
+			chosenAction = invalidActionMenuItem;
+		}
+		
+		chosenAction.runAction();
+	}
+	
+	
+}
\ No newline at end of file
diff --git a/src/lib/com/izforge/izpack/installer/ConsolePager.java b/src/lib/com/izforge/izpack/installer/ConsolePager.java
new file mode 100644
index 0000000..bf2ad7f
--- /dev/null
+++ b/src/lib/com/izforge/izpack/installer/ConsolePager.java
@@ -0,0 +1,41 @@
+package com.izforge.izpack.installer;
+
+import java.io.IOException;
+import java.util.List;
+
+public class ConsolePager 
+{
+	private static TextHelper textHelper = new TextHelper();
+	
+	private static int DEFAULT_NO_OF_LINES = 20;
+	private static String DEFAULT_PROMPT = "--- Press ENTER to continue ---";
+	
+	public void displayLongText(String text) 
+	throws IOException 
+	{
+		displayLongText(
+				text, 
+				DEFAULT_NO_OF_LINES,
+				DEFAULT_PROMPT);
+	}
+	
+	public void displayLongText(
+			String text, 
+			int noOfLinesEach, 
+			String continuePrompt) 
+	throws IOException 
+	{
+		List<String> lines = textHelper.convertToLines(text);
+		
+		ConsoleHelper helper = new ConsoleHelper();
+		for (int i = 0 ; i < lines.size() ; i++) 
+		{
+			System.out.println(lines.get(i));
+			if (i != 0 && i % noOfLinesEach == 0) 
+			{
+				helper.displayAndBlock(continuePrompt);
+			}
+		}
+	}
+	
+}
\ No newline at end of file
diff --git a/src/lib/com/izforge/izpack/installer/HTMLHelper.java b/src/lib/com/izforge/izpack/installer/HTMLHelper.java
new file mode 100644
index 0000000..1c0e7d6
--- /dev/null
+++ b/src/lib/com/izforge/izpack/installer/HTMLHelper.java
@@ -0,0 +1,40 @@
+package com.izforge.izpack.installer;
+
+
+public class HTMLHelper {
+	
+	public String extractTextFromSimplifiedHTML(String htmlString) {
+		// pattern relates to replace, when updating
+		// be careful to keep the indexes in order
+		// replacements will be performed in the same order
+		// as they are in the two arrays
+		String[] patterns = {
+				"<[^>]*>",
+				"&lt;",
+				"&gt;",
+				"&amp;",
+				"&copy;",
+				"&ldquo;",
+				"&rdquo;"
+		};
+		String[] replaces = {
+				"", // remove tags
+				"<", // resolve <
+				">", // resolve >
+				"&", // resolve &
+				"(C)", // turns &copy; to "(C)"
+				"\"", // resolve left quotation
+				"\"", // resolve right quotation
+		};
+		
+		String result = htmlString;
+		for (int i = 0 ; i < patterns.length ; i++) {
+			String pattern = patterns[i];
+			String replace = replaces[i];
+			result = result.replaceAll(pattern, replace);
+		}
+		
+		return result;
+	}
+	
+}
\ No newline at end of file
diff --git a/src/lib/com/izforge/izpack/installer/IConsoleMenuItem.java b/src/lib/com/izforge/izpack/installer/IConsoleMenuItem.java
new file mode 100644
index 0000000..b737d3b
--- /dev/null
+++ b/src/lib/com/izforge/izpack/installer/IConsoleMenuItem.java
@@ -0,0 +1,6 @@
+package com.izforge.izpack.installer;
+
+public interface IConsoleMenuItem {
+	public String renderToString();
+	public void runAction();
+}
\ No newline at end of file
diff --git a/src/lib/com/izforge/izpack/installer/Option.java b/src/lib/com/izforge/izpack/installer/Option.java
new file mode 100644
index 0000000..f3abcae
--- /dev/null
+++ b/src/lib/com/izforge/izpack/installer/Option.java
@@ -0,0 +1,25 @@
+package com.izforge.izpack.installer;
+
+// Optional parameter (makes optional parameters handling explicit)
+// it has two states:
+//   defined -> isDefined == true, value holds value
+//   undefined -> isDefined == false, msg holds reason of emptiness
+public class Option<T> {
+	public final boolean isDefined;
+	public final T value;
+	public final String msg;
+	
+	private Option(boolean isDefined, T value, String msg) {
+		this.isDefined = isDefined;
+		this.value = value;
+		this.msg = msg;
+	}
+	
+	public static <T> Option<T> full(T value) {
+		return new Option<T>(true, value, null);
+	}
+	
+	public static <T> Option<T> empty(String msg) {
+		return new Option<T>(false, null, msg);
+	}
+}
diff --git a/src/lib/com/izforge/izpack/installer/PanelConsoleHelper.java b/src/lib/com/izforge/izpack/installer/PanelConsoleHelper.java
index b6d9daa..053c035 100644
--- a/src/lib/com/izforge/izpack/installer/PanelConsoleHelper.java
+++ b/src/lib/com/izforge/izpack/installer/PanelConsoleHelper.java
@@ -24,6 +24,9 @@ import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
 
+import com.izforge.izpack.Panel;
+import com.izforge.izpack.util.VariableSubstitutor;
+
 /**
  * Abstract class implementing basic functions needed by all panel console helpers.
  * 
@@ -32,9 +35,9 @@ import java.io.InputStreamReader;
 abstract public class PanelConsoleHelper 
 {
 
+	public enum PanelContinuation { CONTINUE, QUIT, REDISPLAY };
 
-
-    public int askEndOfConsolePanel()
+    private PanelContinuation askEndOfConsolePanel()
     {
         try
         {
@@ -45,13 +48,15 @@ abstract public class PanelConsoleHelper
                 String strIn = br.readLine();
                 if (strIn.equals("1"))
                 {
-                    return 1;
+                    return PanelContinuation.CONTINUE;
                 }
                 else if (strIn.equals("2"))
                 {
-                    return 2;
+                    return PanelContinuation.QUIT;
+                }
+                else if (strIn.equals("3")) { 
+                	return PanelContinuation.REDISPLAY; 
                 }
-                else if (strIn.equals("3")) { return 3; }
             }
 
         }
@@ -59,7 +64,94 @@ abstract public class PanelConsoleHelper
         {
             e.printStackTrace();
         }
-        return 2;
+        return PanelContinuation.QUIT;
+    }
+    
+    protected boolean continueQuitOrReboot(
+    		AutomatedInstallData idata, PanelConsole panel
+    		) {
+    	PanelContinuation userChoice = askEndOfConsolePanel();
+        if (userChoice == PanelContinuation.CONTINUE)
+        {
+            return true;
+        }
+        else if (userChoice == PanelContinuation.QUIT)
+        {
+            return false;
+        }
+        else
+        {
+            return panel.runConsole(idata);
+        }
+    }
+    
+
+    
+    private String extractPanelNameFromConsoleHelperClassName(String className) {
+        final String consoleHelperSuffix = "ConsoleHelper";
+        final int suffixIndex = className.indexOf(consoleHelperSuffix);
+        if (suffixIndex == -1) {
+        	throw new IllegalStateException("Trying to get i18n info from a " +
+        			"class which is not a ConsoleHelper, not allowed");
+        }
+    	return className.substring(0, suffixIndex);
+    }
+
+    // this method gets i18n string for the panel related to the caller 
+    // console helper object, to be used only from classes with name ending with 
+    // ConsoleHelper suffix
+    protected String getI18nStringForClass(String subkey, String alternateClass, AutomatedInstallData idata)
+    {
+        final String thisClassName = getClass().getName();
+        final String panelClassName = extractPanelNameFromConsoleHelperClassName(thisClassName);
+        
+    	return (getI18nStringForClass(panelClassName, subkey, alternateClass, null, idata));
+    }
+
+    private String getI18nStringForClass(
+    		String curClassName, 
+    		String subkey, 
+    		String alternateClass,
+    		Panel metadata,
+    		AutomatedInstallData idata)
+    {
+
+        int nameStart = curClassName.lastIndexOf('.') + 1;
+        curClassName = curClassName.substring(nameStart, curClassName.length());
+        StringBuffer buf = new StringBuffer();
+        buf.append(curClassName).append(".").append(subkey);
+        String fullkey = buf.toString();
+        String panelid = null;
+        if (metadata != null)
+        {
+            panelid = metadata.getPanelid();
+        }
+        String retval = null;
+        if (panelid != null)
+        {
+            buf.append(".");
+            buf.append(panelid);
+            retval = idata.langpack.getString(buf.toString());
+        }
+        if (retval == null || retval.startsWith(fullkey))
+        {
+            retval = idata.langpack.getString(fullkey);
+        }
+        if (retval == null || retval.startsWith(fullkey))
+        {
+            if (alternateClass == null) { return (null); }
+            buf.delete(0, buf.length());
+            buf.append(alternateClass).append(".").append(subkey);
+            retval = idata.langpack.getString(buf.toString());
+        }
+        if (retval != null && retval.indexOf('$') > -1)
+        {
+            VariableSubstitutor substitutor = new VariableSubstitutor(idata.getVariables());
+            retval = substitutor.substitute(retval, null);
+        }
+        return (retval);
     }
 
+    
+    
 }
diff --git a/src/lib/com/izforge/izpack/installer/ResourceHelper.java b/src/lib/com/izforge/izpack/installer/ResourceHelper.java
new file mode 100644
index 0000000..2f5a28f
--- /dev/null
+++ b/src/lib/com/izforge/izpack/installer/ResourceHelper.java
@@ -0,0 +1,31 @@
+package com.izforge.izpack.installer;
+
+import java.io.BufferedReader;
+import java.io.InputStreamReader;
+import java.net.URL;
+
+public class ResourceHelper {
+	
+	public String getResourceAsString(String resourceId) 
+	throws ResourceNotFoundException
+	{
+        try
+        {
+            URL url = ResourceManager.getInstance().getURL(resourceId);
+            if (url == null) 
+            {
+            	throw new RuntimeException("Invalid resource URL");
+            }
+            
+            InputStreamReader reader = new InputStreamReader(url.openStream());
+            BufferedReader bufferedReader = new BufferedReader(reader);
+            return new IOHelper().readAll(bufferedReader);
+        }
+        catch (Exception ex)
+        {
+            throw new ResourceNotFoundException(
+            		"Error loading resource " + resourceId);
+        }
+	}
+
+}
\ No newline at end of file
diff --git a/src/lib/com/izforge/izpack/installer/ValidatingConverter.java b/src/lib/com/izforge/izpack/installer/ValidatingConverter.java
new file mode 100644
index 0000000..36542e3
--- /dev/null
+++ b/src/lib/com/izforge/izpack/installer/ValidatingConverter.java
@@ -0,0 +1,8 @@
+package com.izforge.izpack.installer;
+
+//does conversion and validates results
+//see Option for result description
+public abstract class ValidatingConverter<F, T> {
+	public abstract Option<T> convert(F from);
+}
+
diff --git a/src/lib/com/izforge/izpack/installer/VariablesHelper.java b/src/lib/com/izforge/izpack/installer/VariablesHelper.java
new file mode 100644
index 0000000..55c7f9b
--- /dev/null
+++ b/src/lib/com/izforge/izpack/installer/VariablesHelper.java
@@ -0,0 +1,28 @@
+package com.izforge.izpack.installer;
+
+import java.util.Properties;
+
+import com.izforge.izpack.util.VariableSubstitutor;
+
+
+public class VariablesHelper {
+	public String expand(String string_to_parse, Properties variables) {
+        try
+        {
+            // Initialize the variable substitutor
+            VariableSubstitutor vs = new VariableSubstitutor(variables);
+
+            // Parses the info text
+            string_to_parse = vs.substitute(string_to_parse, null);
+        }
+        catch (Exception err)
+        {
+            err.printStackTrace();
+        }
+        return string_to_parse;
+	}
+	
+	public String expand(String string_to_parse, AutomatedInstallData idata) {
+		return expand(string_to_parse, idata.getVariables());
+	}
+}
\ No newline at end of file
diff --git a/src/lib/com/izforge/izpack/panels/CheckedHelloPanelConsoleHelper.java b/src/lib/com/izforge/izpack/panels/CheckedHelloPanelConsoleHelper.java
new file mode 100644
index 0000000..d5feff3
--- /dev/null
+++ b/src/lib/com/izforge/izpack/panels/CheckedHelloPanelConsoleHelper.java
@@ -0,0 +1,4 @@
+package com.izforge.izpack.panels;
+
+public class CheckedHelloPanelConsoleHelper 
+extends HelloPanelConsoleHelper {}
diff --git a/src/lib/com/izforge/izpack/panels/DerbyPathPanel.java b/src/lib/com/izforge/izpack/panels/DerbyPathPanel.java
new file mode 100644
index 0000000..7d66dc2
--- /dev/null
+++ b/src/lib/com/izforge/izpack/panels/DerbyPathPanel.java
@@ -0,0 +1,167 @@
+package com.izforge.izpack.panels;
+
+import com.izforge.izpack.installer.AutomatedInstallData;
+import com.izforge.izpack.installer.InstallData;
+import com.izforge.izpack.installer.InstallerFrame;
+import com.izforge.izpack.util.AbstractUIHandler;
+import com.izforge.izpack.util.FileExecutor;
+import com.izforge.izpack.util.OsVersion;
+import com.izforge.izpack.util.os.RegistryDefaultHandler;
+import com.izforge.izpack.util.os.RegistryHandler;
+import com.izforge.izpack.util.VariableSubstitutor;
+
+import java.io.File;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.StringTokenizer;
+
+/**
+ * Panel which asks for the Derby database path.
+ *
+ * @author Klaus Bartz
+ */
+public class DerbyPathPanel extends PathInputPanel {
+
+	private static final long serialVersionUID = 1L;
+
+	private String variableName = null;
+
+	private DerbyPathPanelHelper helper = new DerbyPathPanelHelper();
+	
+	/**
+	 * The constructor.
+	 *
+	 * @param parent The parent window.
+	 * @param idata  The installation data.
+	 */
+	public DerbyPathPanel(InstallerFrame parent, InstallData idata) {
+		super(parent, TigaseInstallerCommon.init(idata));
+		setMustExist(false);
+		setVariableName(helper.getVariableName());
+	}
+
+	/**
+	 * Indicates wether the panel has been validated or not.
+	 *
+	 * @return Wether the panel has been validated or not.
+	 */
+	public boolean isValidated()
+	{
+		boolean retval = false;
+		if (super.isValidated()) {
+			idata.setVariable(getVariableName(), pathSelectionPanel.getPath());
+			return true;
+		}
+		return false;
+	}
+
+	/**
+	 * Called when the panel becomes active.
+	 */
+	public void panelActivate()
+	{
+		// Resolve the default for chosenPath
+		super.panelActivate();
+		// The variable will be exist if we enter this panel
+		// second time. We would maintain the previos
+		// selected path.
+//		if (idata.getVariable(getVariableName()) != null) {
+//			chosenPath = idata.getVariable(getVariableName());
+//		} else {
+//			if (OsVersion.IS_WINDOWS)	{
+//				chosenPath = idata.getVariable(getVariableName()+".windows");
+//			}
+//			if (OsVersion.IS_OSX)	{
+//				chosenPath = idata.getVariable(getVariableName()+".mac");
+//			} else {
+//				if (OsVersion.IS_UNIX)	{
+//					chosenPath = idata.getVariable(getVariableName()+".unix");
+//				}
+//			}
+//		}
+//		VariableSubstitutor vs = new VariableSubstitutor(idata.getVariables());
+//		chosenPath = vs.substitute(chosenPath, null);
+//		// Set the path for method pathIsValid ...
+		
+		String chosenPath = helper.getDefaultPath(idata);
+		pathSelectionPanel.setPath(chosenPath);
+
+		if (!pathIsValid())
+		{
+			chosenPath = "";
+		}
+		// Set the default to the path selection panel.
+		pathSelectionPanel.setPath(chosenPath);
+// 		String var = idata.getVariable("DerbyPathPanel.skipIfValid");
+// 		// Should we skip this panel?
+// 		if (chosenPath.length() > 0 && var != null && "yes".equalsIgnoreCase(var))
+// 		{
+// 			idata.setVariable(getVariableName(), chosenPath);
+// 			parent.skipPanel();
+// 		}
+
+	}
+
+	/**
+	 * Returns the name of the variable which should be used for the path.
+	 *
+	 * @return the name of the variable which should be used for the path
+	 */
+	public String getVariableName()
+	{
+		return variableName;
+	}
+
+	/**
+	 * Sets the name for the variable which should be set with the path.
+	 *
+	 * @param string variable name to be used
+	 */
+	public void setVariableName(String string)
+	{
+		variableName = string;
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * 
+	 * @see com.izforge.izpack.installer.IzPanel#getSummaryBody()
+	 */
+	public String getSummaryBody()
+	{
+		return (idata.getVariable(getVariableName()));
+	}
+}
+
+class DerbyPathPanelHelper {
+	
+	String getVariableName() {
+		return "DerbyDBPath";
+	}
+	
+	String getDefaultPath(AutomatedInstallData idata) {
+		String chosenPath = "";
+		if (idata.getVariable(getVariableName()) != null) {
+			chosenPath = idata.getVariable(getVariableName());
+		} else {
+			if (OsVersion.IS_WINDOWS)	{
+				chosenPath = idata.getVariable(getVariableName()+".windows");
+			}
+			if (OsVersion.IS_OSX)	{
+				chosenPath = idata.getVariable(getVariableName()+".mac");
+			} else {
+				if (OsVersion.IS_UNIX)	{
+					chosenPath = idata.getVariable(getVariableName()+".unix");
+				}
+			}
+		}
+		VariableSubstitutor vs = new VariableSubstitutor(idata.getVariables());
+		chosenPath = vs.substitute(chosenPath, null);
+		return chosenPath;
+	}
+
+	public void setDefaultPath(AutomatedInstallData installData) {
+		installData.setVariable(getVariableName(), getDefaultPath(installData));
+	}
+}
diff --git a/src/lib/com/izforge/izpack/panels/HTMLInfoPanel.java b/src/lib/com/izforge/izpack/panels/HTMLInfoPanel.java
index 8a14d89..a47d3ff 100644
--- a/src/lib/com/izforge/izpack/panels/HTMLInfoPanel.java
+++ b/src/lib/com/izforge/izpack/panels/HTMLInfoPanel.java
@@ -46,6 +46,8 @@ public class HTMLInfoPanel extends IzPanel
 
     private static final long serialVersionUID = 3257008769514025270L;
 
+    static final String HTMLINFO_PANEL_NAME = "HTMLInfoPanel";
+
     /** Resource prefix for panel. */
     protected String panelResourcePrefixStr;
 
@@ -65,7 +67,7 @@ public class HTMLInfoPanel extends IzPanel
      */
     public HTMLInfoPanel(InstallerFrame parent, InstallData idata)
     {
-        this(parent,idata,"HTMLInfoPanel",true);
+        this(parent,idata,HTMLINFO_PANEL_NAME,true);
     }
 
     /**
diff --git a/src/lib/com/izforge/izpack/panels/HTMLInfoPanelConsoleHelper.java b/src/lib/com/izforge/izpack/panels/HTMLInfoPanelConsoleHelper.java
new file mode 100644
index 0000000..aac6d9a
--- /dev/null
+++ b/src/lib/com/izforge/izpack/panels/HTMLInfoPanelConsoleHelper.java
@@ -0,0 +1,63 @@
+package com.izforge.izpack.panels;
+
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.util.Properties;
+
+import com.izforge.izpack.installer.AutomatedInstallData;
+import com.izforge.izpack.installer.ConsoleInstallHelper;
+import com.izforge.izpack.installer.PanelConsole;
+import com.izforge.izpack.installer.PanelConsoleHelper;
+import com.izforge.izpack.installer.ResourceNotFoundException;
+
+
+// hardcoded resource name, should work only for standard one html panel
+// uses simple html format, and extracts text from it using regex
+// only interactive mode implemented
+public class HTMLInfoPanelConsoleHelper extends PanelConsoleHelper implements PanelConsole 
+{
+	private ConsoleInstallHelper helper = ConsoleInstallHelper.getInstance();
+		
+	public boolean runConsole(AutomatedInstallData installData) 
+	{
+		try {
+			// load resource
+			//TODO how to get resource id from installData?
+			String resourceId = "HTMLInfoPanel.info"; 
+			String htmlInfo = helper.resource.getResourceAsString(resourceId);
+			htmlInfo = helper.variables.expand(htmlInfo, installData);
+			
+			// convert from html
+			String info = helper.html.extractTextFromSimplifiedHTML(htmlInfo);
+
+			// display using pager
+			helper.pager.displayLongText(info);
+		}
+		catch (ResourceNotFoundException re) {
+			re.printStackTrace();
+			return false;
+		}
+		catch (IOException ioe) {
+			ioe.printStackTrace();
+			return false;
+		}
+				
+		return continueQuitOrReboot(installData, this);
+	}
+
+	
+	
+	
+	// not implemented
+	
+	public boolean runConsoleFromPropertiesFile(
+			AutomatedInstallData installData, Properties p) {
+		return false;
+	}
+
+	public boolean runGeneratePropertiesFile(AutomatedInstallData installData,
+			PrintWriter printWriter) {
+		return false;
+	}
+
+}
diff --git a/src/lib/com/izforge/izpack/panels/HTMLLicencePanelConsoleHelper.java b/src/lib/com/izforge/izpack/panels/HTMLLicencePanelConsoleHelper.java
new file mode 100644
index 0000000..c3e994c
--- /dev/null
+++ b/src/lib/com/izforge/izpack/panels/HTMLLicencePanelConsoleHelper.java
@@ -0,0 +1,69 @@
+package com.izforge.izpack.panels;
+
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.util.Properties;
+
+import com.izforge.izpack.installer.AutomatedInstallData;
+import com.izforge.izpack.installer.ConsoleInstallHelper;
+import com.izforge.izpack.installer.PanelConsole;
+import com.izforge.izpack.installer.PanelConsoleHelper;
+import com.izforge.izpack.installer.ResourceNotFoundException;
+
+public class HTMLLicencePanelConsoleHelper 
+extends PanelConsoleHelper 
+implements PanelConsole
+{
+
+	private ConsoleInstallHelper helper = ConsoleInstallHelper.getInstance();
+	
+	public boolean runConsole(AutomatedInstallData installData) {
+		String headerLabel = installData.langpack.getString("LicencePanel.info");
+		helper.console.displayLabel(headerLabel);
+		
+		try {
+			// load resource
+			//TODO how to get resource id from installData?
+			String resourceId = "HTMLLicencePanel.licence"; 
+			String htmlInfo = helper.resource.getResourceAsString(resourceId);
+			htmlInfo = helper.variables.expand(htmlInfo, installData);
+			
+			// convert from html
+			String info = helper.html.extractTextFromSimplifiedHTML(htmlInfo);
+
+			// display using pager
+			helper.pager.displayLongText(info);
+			
+			String iAgree = installData.langpack.getString("LicencePanel.agree");
+			String iDoNotAgree = installData.langpack.getString("LicencePanel.notagree");
+			switch (helper.console.chooseAction(iAgree, iDoNotAgree)) {
+			case 1: return continueQuitOrReboot(installData, this);
+			case 2: return false;
+			}
+			
+		}
+		catch (ResourceNotFoundException re) {
+			re.printStackTrace();
+			return false;
+		}
+		catch (IOException ioe) {
+			ioe.printStackTrace();
+			return false;
+		}
+		
+		// should be unreachable
+		return false;
+	}
+
+	
+	// not implemented
+	public boolean runConsoleFromPropertiesFile(
+			AutomatedInstallData installData, Properties p) {
+		return false;
+	}
+
+	public boolean runGeneratePropertiesFile(AutomatedInstallData installData,
+			PrintWriter printWriter) {
+		return false;
+	}
+}
diff --git a/src/lib/com/izforge/izpack/panels/HelloPanelConsoleHelper.java b/src/lib/com/izforge/izpack/panels/HelloPanelConsoleHelper.java
index bfb075a..f42d5f0 100644
--- a/src/lib/com/izforge/izpack/panels/HelloPanelConsoleHelper.java
+++ b/src/lib/com/izforge/izpack/panels/HelloPanelConsoleHelper.java
@@ -26,6 +26,7 @@ import java.util.Properties;
 
 import com.izforge.izpack.Info;
 import com.izforge.izpack.installer.AutomatedInstallData;
+import com.izforge.izpack.installer.ConsoleInstallHelper;
 import com.izforge.izpack.installer.PanelConsole;
 import com.izforge.izpack.installer.PanelConsoleHelper;
 
@@ -36,6 +37,8 @@ import com.izforge.izpack.installer.PanelConsoleHelper;
  */
 public class HelloPanelConsoleHelper extends PanelConsoleHelper implements PanelConsole
 {
+	
+	private static ConsoleInstallHelper helper = ConsoleInstallHelper.getInstance();
 
     public boolean runConsoleFromPropertiesFile(AutomatedInstallData installData, Properties p)
     {
@@ -53,6 +56,7 @@ public class HelloPanelConsoleHelper extends PanelConsoleHelper implements Panel
         String str;
         str = idata.langpack.getString("HelloPanel.welcome1") + idata.info.getAppName() + " "
                 + idata.info.getAppVersion() + idata.langpack.getString("HelloPanel.welcome2");
+        str = helper.variables.expand(str, idata);
         System.out.println(str);
         ArrayList<Info.Author> authors = idata.info.getAuthors();
         int size = authors.size();
@@ -75,18 +79,7 @@ public class HelloPanelConsoleHelper extends PanelConsoleHelper implements Panel
             str = idata.langpack.getString("HelloPanel.url") + idata.info.getAppURL();
             System.out.println(str);
         }
-        int i = askEndOfConsolePanel();
-        if (i == 1)
-        {
-            return true;
-        }
-        else if (i == 2)
-        {
-            return false;
-        }
-        else
-        {
-            return runConsole(idata);
-        }
+        
+        return continueQuitOrReboot(idata, this);
     }
 }
diff --git a/src/lib/com/izforge/izpack/panels/JDKPathPanelConsoleHelper.java b/src/lib/com/izforge/izpack/panels/JDKPathPanelConsoleHelper.java
new file mode 100644
index 0000000..00d3b03
--- /dev/null
+++ b/src/lib/com/izforge/izpack/panels/JDKPathPanelConsoleHelper.java
@@ -0,0 +1,51 @@
+package com.izforge.izpack.panels;
+
+import java.io.File;
+import java.io.PrintWriter;
+import java.util.Properties;
+
+import com.izforge.izpack.installer.AutomatedInstallData;
+import com.izforge.izpack.installer.Option;
+import com.izforge.izpack.installer.ValidatingConverter;
+
+public class JDKPathPanelConsoleHelper extends PathInputPanelConsoleHelper {
+
+	private final static String JDK_PATH_VARIABLE_NAME = "JDKPath";
+	
+	public boolean runConsole(AutomatedInstallData installData) {
+		return super.runConsole(installData);
+	}
+
+	public boolean runConsoleFromPropertiesFile(
+			AutomatedInstallData installData, Properties p) {
+		return super.runConsoleFromPropertiesFile(installData, p);
+	}
+
+	public boolean runGeneratePropertiesFile(AutomatedInstallData installData,
+			PrintWriter printWriter) {
+		return super.runGeneratePropertiesFile(installData, printWriter);
+	}
+
+	// sorry, no proper version validation, no version check
+	// everything needs to be extracted
+	// or (preferably) accessed from JDKPathPanel, I couldn't do it, too complicated :/
+	public ValidatingConverter<String, File> getPathValidator() {
+		return new ValidatingConverter<String, File>() {
+			public Option<File> convert(String line) {
+				File file = new File(line);
+				if (file.exists() == false) {
+					return Option.empty("Path doesn't exist");
+				} else {
+					return Option.full(file);
+				}
+			}        	
+		};
+	}	
+
+	public void onResult(File inputPath, AutomatedInstallData iData) {
+		iData.setVariable(
+				JDK_PATH_VARIABLE_NAME, 
+				inputPath.getAbsolutePath().toString());
+	}
+
+}
\ No newline at end of file
diff --git a/src/lib/com/izforge/izpack/panels/PacksPanelConsoleHelper.java b/src/lib/com/izforge/izpack/panels/PacksPanelConsoleHelper.java
new file mode 100644
index 0000000..9cf07d8
--- /dev/null
+++ b/src/lib/com/izforge/izpack/panels/PacksPanelConsoleHelper.java
@@ -0,0 +1,118 @@
+package com.izforge.izpack.panels;
+
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Properties;
+
+import com.izforge.izpack.Pack;
+import com.izforge.izpack.installer.AutomatedInstallData;
+import com.izforge.izpack.installer.ConsoleInstallHelper;
+import com.izforge.izpack.installer.ConsoleMenu;
+import com.izforge.izpack.installer.IConsoleMenuItem;
+import com.izforge.izpack.installer.PanelConsole;
+import com.izforge.izpack.installer.PanelConsoleHelper;
+import com.izforge.izpack.panels.PacksHelper.PackSelection;
+public class PacksPanelConsoleHelper 
+extends PanelConsoleHelper 
+implements PanelConsole 
+{
+
+	private PacksHelper packsHelper = new PacksHelper();
+	private ConsoleInstallHelper helper = ConsoleInstallHelper.getInstance();
+	
+	public boolean runConsole(final AutomatedInstallData installData) {
+
+		final List<IConsoleMenuItem> items 
+			= packsHelper.getPacksSelections(installData);
+		try {
+			final String info = installData.langpack.getString("PacksPanel.info");
+			
+			ConsoleMenu consoleMenu = new ConsoleMenu(helper.console) {
+				protected List<IConsoleMenuItem> getMenuItems() {
+					return items;
+				}
+
+				protected String getHeader() {
+					return info;
+				}
+			};
+			consoleMenu.run();
+			
+			List<Pack> selectedPacks = new ArrayList<Pack>();
+			for (IConsoleMenuItem pack : items) {
+				PackSelection selection = (PackSelection) pack;
+				if (selection.isSelected) 
+				{
+					selectedPacks.add(selection.getPack());
+				}
+			}
+			
+			installData.selectedPacks = selectedPacks;
+			
+		} catch (IOException e) {
+			e.printStackTrace();
+			return false;
+		} 
+		
+		return continueQuitOrReboot(installData, this);
+	}
+
+	
+	
+	
+	// not implemented
+	public boolean runConsoleFromPropertiesFile(
+			AutomatedInstallData installData, Properties p) {
+		return false;
+	}
+
+	public boolean runGeneratePropertiesFile(AutomatedInstallData installData,
+			PrintWriter printWriter) {
+		return false;
+	}
+
+}
+
+class PacksHelper {
+	
+	public List<IConsoleMenuItem> getPacksSelections(AutomatedInstallData installData) {
+		List<IConsoleMenuItem> result = new ArrayList<IConsoleMenuItem>();
+		for (Pack pack : installData.availablePacks) {
+			result.add(new PackSelection(pack)); 
+		}
+		return result;
+	}
+	
+	class PackSelection implements IConsoleMenuItem {
+		final Pack pack;
+		boolean isSelected;
+		
+		public PackSelection(Pack pack) {
+			this.pack = pack;
+			this.isSelected = pack.preselected;
+		}
+
+		public Pack getPack() {
+			return pack;
+		}
+
+		public String renderToString() {
+			String option = "";
+			if (pack.required == false) {
+				String selected = isSelected ? "x" : " ";
+				option = "[" + selected + "] ";
+			}
+			return option + pack.name + ", " + pack.description;
+		}
+
+		public void runAction() {
+			if (pack.required == false) {
+				isSelected = !isSelected;
+			} 
+		}
+	}
+	
+}
+
diff --git a/src/lib/com/izforge/izpack/panels/PathInputPanelConsoleHelper.java b/src/lib/com/izforge/izpack/panels/PathInputPanelConsoleHelper.java
new file mode 100644
index 0000000..cfc0dd8
--- /dev/null
+++ b/src/lib/com/izforge/izpack/panels/PathInputPanelConsoleHelper.java
@@ -0,0 +1,68 @@
+package com.izforge.izpack.panels;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.util.Properties;
+
+import com.izforge.izpack.installer.AutomatedInstallData;
+import com.izforge.izpack.installer.ConsoleInstallHelper;
+import com.izforge.izpack.installer.PanelConsole;
+import com.izforge.izpack.installer.PanelConsoleHelper;
+import com.izforge.izpack.installer.ValidatingConverter;
+
+public abstract class PathInputPanelConsoleHelper extends PanelConsoleHelper implements PanelConsole {
+
+    protected ConsoleInstallHelper helper = ConsoleInstallHelper.getInstance();
+    
+    private String getIntroText(AutomatedInstallData installData) {
+        String introText = getI18nStringForClass("extendedIntro", "PathInputPanel", installData);
+        if (introText == null || introText.endsWith("extendedIntro")
+                || introText.indexOf('$') > -1)
+        {
+            introText = getI18nStringForClass("intro", "PathInputPanel", installData);
+            if (introText == null || introText.endsWith("intro"))
+            {
+                introText = "";
+            }
+        }
+        return introText;
+    }
+    
+	public boolean runConsole(AutomatedInstallData installData) 
+	{
+		try {
+			final String introText = getIntroText(installData);
+	        helper.console.displayLabel(introText);
+	        
+	        // get valid path
+	        ValidatingConverter<String, File> pathValidator = getPathValidator();
+			File inputPath = helper.console.readUntilValid(
+					"Enter path",
+					pathValidator);	
+			
+			onResult(inputPath, installData);
+		}
+		catch (IOException ioe) {
+			ioe.printStackTrace();
+			return false;
+		}
+		
+		return true;
+	}
+
+	public abstract ValidatingConverter<String, File> getPathValidator();
+	
+	abstract public void onResult(File inputPath, AutomatedInstallData iData);
+
+	public boolean runConsoleFromPropertiesFile(
+			AutomatedInstallData installData, Properties p) {
+		return false;
+	}
+
+	public boolean runGeneratePropertiesFile(AutomatedInstallData installData,
+			PrintWriter printWriter) {
+		return false;
+	}
+
+}
diff --git a/src/lib/com/izforge/izpack/panels/TargetPanel.java b/src/lib/com/izforge/izpack/panels/TargetPanel.java
index 7cf4ce2..03004f0 100644
--- a/src/lib/com/izforge/izpack/panels/TargetPanel.java
+++ b/src/lib/com/izforge/izpack/panels/TargetPanel.java
@@ -21,6 +21,8 @@
 
 package com.izforge.izpack.panels;
 
+import java.io.File;
+
 import com.izforge.izpack.installer.InstallData;
 import com.izforge.izpack.installer.InstallerFrame;
 import com.izforge.izpack.adaptator.IXMLElement;
@@ -84,7 +86,22 @@ public class TargetPanel extends PathInputPanel
      */
     public boolean isValidated()
     {
-        // Standard behavior of PathInputPanel.
+    	{
+    		// TODO: to be removed later
+    		// currently it is done to avoid installation 
+    		// over old Tigase directory, as there is a bug in the unpacker
+    		// http://jira.codehaus.org/browse/IZPACK-395
+    		File testDir = new File(pathSelectionPanel.getPath());
+    		File serverFile = new File(testDir, "jars/tigase-server.jar");
+    		if (serverFile.exists()) {
+    			String msg = "Installation over existing Tigase directory \n" +
+    					"is not supported right now.";
+    			emitError("Error", msg);
+    			return false;
+    		}
+    	}
+    	
+    	// Standard behavior of PathInputPanel.
         if (!super.isValidated())
         {
             return (false);
diff --git a/src/lib/com/izforge/izpack/panels/TargetPanelConsoleHelper.java b/src/lib/com/izforge/izpack/panels/TargetPanelConsoleHelper.java
index 964eec9..a3f0d85 100644
--- a/src/lib/com/izforge/izpack/panels/TargetPanelConsoleHelper.java
+++ b/src/lib/com/izforge/izpack/panels/TargetPanelConsoleHelper.java
@@ -95,19 +95,7 @@ public class TargetPanelConsoleHelper extends PanelConsoleHelper implements Pane
         strTargetPath = vs.substitute(strTargetPath, null);
 
         idata.setInstallPath(strTargetPath);
-        int i = askEndOfConsolePanel();
-        if (i == 1)
-        {
-            return true;
-        }
-        else if (i == 2)
-        {
-            return false;
-        }
-        else
-        {
-            return runConsole(idata);
-        }
 
+        return continueQuitOrReboot(idata, this);
     }
 }
diff --git a/src/lib/com/izforge/izpack/panels/TigaseConfigConst.java b/src/lib/com/izforge/izpack/panels/TigaseConfigConst.java
new file mode 100644
index 0000000..2952d2e
--- /dev/null
+++ b/src/lib/com/izforge/izpack/panels/TigaseConfigConst.java
@@ -0,0 +1,157 @@
+/*  Tigase Project
+ *  Copyright (C) 2004-2012 "Artur Hefczyc" <artur.hefczyc@tigase.org>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. Look for COPYING file in the top folder.
+ * If not, see http://www.gnu.org/licenses/.
+ *
+ * $Rev$
+ * Last modified by $Author$
+ * $Date$
+ */
+package com.izforge.izpack.panels;
+
+import java.util.LinkedHashMap;
+import java.util.Properties;
+
+/**
+ * Describe class TigaseConfigConst here.
+ *
+ *
+ * Created: Sat Oct 25 21:23:06 2008
+ *
+ * @author <a href="mailto:artur.hefczyc@gmail.com">Artur Hefczyc</a>
+ * @version $Rev$
+ */
+public abstract class TigaseConfigConst {
+
+	public static Properties props = null;
+
+	public static LinkedHashMap<String, String> tigaseIzPackMap =
+    new LinkedHashMap<String, String>();
+// 	public static LinkedHashMap<String, String> izPackTigaseMap =
+//     new LinkedHashMap<String, String>();
+
+	public static LinkedHashMap<String, String> userDBMap =
+    new LinkedHashMap<String, String>();
+
+	public static LinkedHashMap<String, String> userDBUriMap =
+    new LinkedHashMap<String, String>();
+
+	public static final String SERVER_DEBUG = "serverDebug";
+	public static final String PLUGIN_DEBUG = "pluginsDebug";
+	public static final String DB_DEBUG = "dbDebug";
+	public static final String CLUSTER_DEBUG = "clusterDebug";
+
+	public static String[] ALL_DEBUGS =
+	{SERVER_DEBUG, PLUGIN_DEBUG, DB_DEBUG, CLUSTER_DEBUG};
+	public static LinkedHashMap<String, String> debugMap =
+    new LinkedHashMap<String, String>();
+
+	public static String[] ALL_PLUGINS =
+	{"nonSaslAuthPlugin", "saslAuthPlugin", "resBindPlugin",
+	 "sessionBindPlugin", "registerPlugin", "rosterPlugin", "presencePlugin", "privacyPlugin",
+	 "versionPlugin", "statsPlugin", "tlsPlugin", "msgOfflinePlugin",
+	 "vcardPlugin", "commandsPlugin", "privatePlugin", "pingPlugin",
+	 "basicFilterPlugin", "domainFilterPlugin", "pepPlugin", "zlibPlugin"};
+	public static LinkedHashMap<String, String> pluginsMap =
+    new LinkedHashMap<String, String>();
+
+	// Special variable names:
+	public static final String DB_TYPE = "dbType";
+	public static final String AUTH_DB = "authDB";
+	public static final String AUTH_HANDLE = "dbAuthHandle";
+	public static final String MUC_COMP = "mucComponent";
+	public static final String PUBSUB_COMP = "pubsubComponent";
+	public static final String PLUGINS = "plugins";
+	public static final String DEBUG = "debug";
+	public static final String USER_DB_URI = "userDBUri";
+	public static final String AUTH_DB_URI = "dbAuthType";
+
+	static {
+		tigaseIzPackMap.put("config-type", "configType");
+		tigaseIzPackMap.put("--virt-hosts", "virtualDomains");
+		tigaseIzPackMap.put("--admins", "admins");
+		tigaseIzPackMap.put("--user-db", DB_TYPE);
+		tigaseIzPackMap.put("--auth-db", AUTH_HANDLE);
+		tigaseIzPackMap.put("--muc", MUC_COMP);
+		tigaseIzPackMap.put("--pubsub", PUBSUB_COMP);
+		tigaseIzPackMap.put("--cluster-mode", "clusterMode");
+		tigaseIzPackMap.put("--cluster-nodes", "clusterNodes");
+		tigaseIzPackMap.put("--debug", DEBUG);
+		tigaseIzPackMap.put("--sm-plugins", PLUGINS);
+		tigaseIzPackMap.put("--user-db-uri", USER_DB_URI);
+		tigaseIzPackMap.put("--auth-db-uri", AUTH_DB_URI);
+// 		for (Map.Entry entry: tigaseIzPackMap.entrySet()) {
+// 			izPackTigaseMap.put(entry.getValue(), entry.getKey());
+// 		}
+
+		userDBMap.put("Derby", "derby");
+		userDBMap.put("MySQL", "mysql");
+		userDBMap.put("PostgreSQL", "pgsql");
+		userDBMap.put("SQLServer", "jtds:sqlserver");
+
+		userDBUriMap.put("derby", "Derby");
+		userDBUriMap.put("mysql", "MySQL");
+		userDBUriMap.put("postgresql", "PostgreSQL");
+		userDBUriMap.put("pgsql", "PostgreSQL");
+		userDBUriMap.put("jtds:sqlserver", "SQLServer");
+
+		debugMap.put("server", SERVER_DEBUG);
+		debugMap.put("db", DB_DEBUG);
+		debugMap.put("xmpp.impl", PLUGIN_DEBUG);
+		debugMap.put("cluster", CLUSTER_DEBUG);
+
+		pluginsMap.put("jabber:iq:auth", "nonSaslAuthPlugin");
+		pluginsMap.put("urn:ietf:params:xml:ns:xmpp-sasl", "saslAuthPlugin");
+		pluginsMap.put("urn:ietf:params:xml:ns:xmpp-bind", "resBindPlugin");
+		pluginsMap.put("urn:ietf:params:xml:ns:xmpp-session", "sessionBindPlugin");
+		pluginsMap.put("jabber:iq:register", "registerPlugin");
+		pluginsMap.put("jabber:iq:roster", "rosterPlugin");
+		pluginsMap.put("presence", "presencePlugin");
+		pluginsMap.put("jabber:iq:privacy", "privacyPlugin");
+		pluginsMap.put("jabber:iq:version", "versionPlugin");
+		pluginsMap.put("http://jabber.org/protocol/stats", "statsPlugin");
+		pluginsMap.put("starttls", "tlsPlugin");
+		pluginsMap.put("msgoffline", "msgOfflinePlugin");
+		pluginsMap.put("vcard-temp", "vcardPlugin");
+		pluginsMap.put("http://jabber.org/protocol/commands", "commandsPlugin");
+		pluginsMap.put("jabber:iq:private", "privatePlugin");
+		pluginsMap.put("urn:xmpp:ping", "pingPlugin");
+		pluginsMap.put("basic-filter", "basicFilterPlugin");
+		pluginsMap.put("domain-filter", "domainFilterPlugin");
+		pluginsMap.put("pep", "pepPlugin");
+		pluginsMap.put("zlib", "zlibPlugin");
+	}
+
+	public static String getPluginId(String pluginVarNameToFind) {
+		for (String pluginId : pluginsMap.keySet()) {
+			String pluginVarName = pluginsMap.get(pluginId);
+			if (pluginVarName.equals(pluginVarNameToFind)) {
+				return pluginId;
+			}
+		}
+		return null;
+	}
+	
+	public static final String PGSQL_DRIVER = "org.postgresql.Driver";
+	public static final String MYSQL_DRIVER = "com.mysql.jdbc.Driver";
+	public static final String DERBY_DRIVER = "org.apache.derby.jdbc.EmbeddedDriver";
+
+	public static final String JDBC_CHECKUSERTABLE_QUERY
+    = "select count(*) from tig_users";
+
+	public static final String JDBC_GETSCHEMAVER_QUERY
+    = "select TigGetDBProperty('schema-version')";
+	public static final String DERBY_GETSCHEMAVER_QUERY
+    = "values TigGetDBProperty('schema-version')";
+
+}
diff --git a/src/lib/com/izforge/izpack/panels/TigaseConfigLoadPanel.java b/src/lib/com/izforge/izpack/panels/TigaseConfigLoadPanel.java
new file mode 100644
index 0000000..576c754
--- /dev/null
+++ b/src/lib/com/izforge/izpack/panels/TigaseConfigLoadPanel.java
@@ -0,0 +1,339 @@
+/*
+ * Tigase Jabber/XMPP Server
+ * Copyright (C) 2004-2012 "Artur Hefczyc" <artur.hefczyc@tigase.org>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. Look for COPYING file in the top folder.
+ * If not, see http://www.gnu.org/licenses/.
+ *
+ * $Rev$
+ * Last modified by $Author$
+ * $Date$
+ */
+
+package com.izforge.izpack.panels;
+
+import java.io.File;
+import java.io.FileReader;
+import java.util.Properties;
+import java.util.Set;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import javax.swing.JScrollPane;
+import javax.swing.JTextArea;
+
+import com.izforge.izpack.gui.IzPanelLayout;
+import com.izforge.izpack.gui.LabelFactory;
+import com.izforge.izpack.installer.AutomatedInstallData;
+import com.izforge.izpack.installer.InstallData;
+import com.izforge.izpack.installer.InstallerFrame;
+import com.izforge.izpack.installer.IzPanel;
+import com.izforge.izpack.util.Debug;
+
+/**
+ * The Hello panel class.
+ *
+ * @author <a href="mailto:artur.hefczyc@tigase.org">Artur Hefczyc</a>
+ * @version $Rev$
+ */
+public class TigaseConfigLoadPanel extends IzPanel {
+
+	/**
+	 *
+	 */
+	private static final long serialVersionUID = 1L;
+
+	private JTextArea textArea = null;
+
+	/**
+	 * The constructor.
+	 *
+	 * @param parent The parent.
+	 * @param idata  The installation data.
+	 */
+	public TigaseConfigLoadPanel(InstallerFrame parent, InstallData idata) {
+		super(parent, TigaseInstallerCommon.init(idata), new IzPanelLayout());
+
+		// The config label.
+		add(LabelFactory.create(parent.langpack.getString("TigaseConfigLoadPanel.info"),
+				parent.icons.getImageIcon("edit"), LEADING), NEXT_LINE);
+		// The text area which shows the info.
+		textArea = new JTextArea("");
+		textArea.setCaretPosition(0);
+		textArea.setEditable(false);
+		JScrollPane scroller = new JScrollPane(textArea);
+		add(scroller, NEXT_LINE);
+		// At end of layouting we should call the completeLayout method also they do nothing.
+		getLayoutHelper().completeLayout();
+	}
+
+	public void panelActivate() {
+		super.panelActivate();
+		// Existing configuration loading
+		Debug.trace("panelActivate called for load pael");
+		String config = new TigaseConfigLoadHelper().loadConfig(idata);
+		textArea.setText(config);
+	}
+
+
+	/**
+	 * Indicates whether the panel has been validated or not.
+	 *
+	 * @return Always true.
+	 */
+	public boolean isValidated() {
+		return true;
+	}
+
+}
+
+class TigaseConfigLoadHelper {
+	
+	String loadConfig(AutomatedInstallData idata) {
+		// Try to read the config file.
+		File configPath = null;
+		StringBuilder config = new StringBuilder();
+		try {
+			if (idata.getVariable("searchTigaseHome") == null
+				|| idata.getVariable("searchTigaseHome").isEmpty()) {
+				configPath = new File(idata.getVariable("INSTALL_PATH"),
+					"etc/init.properties");
+			} else {
+				configPath = new File(idata.getVariable("searchTigaseHome"),
+					"etc/init.properties");
+			}
+			if (configPath.exists()) {
+				Properties props = new Properties();
+				props.load(new FileReader(configPath));
+				Debug.trace("Loading init.properties file...");
+				for (String name: props.stringPropertyNames()) {
+					config.append(name + " = " + props.getProperty(name) + "\n");
+				}
+				Debug.trace(config);
+				Debug.trace("Done.");
+				Debug.trace("Loading variables....");
+				for (String name: TigaseConfigConst.tigaseIzPackMap.keySet()) {
+					String varName = TigaseConfigConst.tigaseIzPackMap.get(name);
+					if (varName != null) {
+						Debug.trace("Loading: " + varName + " = " + props.getProperty(name));
+
+						if (varName.equals(TigaseConfigConst.DEBUG)) {
+							if (props.getProperty(name) != null) {
+								parseDebugs(props.getProperty(name), idata);
+								Debug.trace("Loaded: " + varName + " = " + props.getProperty(name));
+							} else {
+								Debug.trace("Missing configuration for " + varName);
+							}
+							continue;
+						}
+
+						if (varName.equals(TigaseConfigConst.PLUGINS)) {
+							if (props.getProperty(name) != null) {
+								parsePlugins(props.getProperty(name), idata);
+								Debug.trace("Loaded: " + varName + " = " + props.getProperty(name));
+							} else {
+								Debug.trace("Missing configuration for " + varName);
+							}
+							continue;
+						}
+
+						if (varName.equals(TigaseConfigConst.USER_DB_URI)) {
+							if (props.getProperty(name) != null) {
+								parseUserDbUri(props.getProperty(name), idata);
+								Debug.trace("Loaded: " + varName + " = " + props.getProperty(name));
+							} else {
+								Debug.trace("Missing configuration for " + varName);
+							}
+							continue;
+						}
+
+						if (varName.equals(TigaseConfigConst.DB_TYPE)) {
+							if (props.getProperty(name) != null) {
+								String dbType =
+                  TigaseConfigConst.userDBUriMap.get(props.getProperty(name));
+								if (dbType == null) {
+									dbType = "Other";
+								}
+								idata.setVariable(TigaseConfigConst.DB_TYPE, dbType);
+								Debug.trace("Loaded: " + varName + " = " + dbType);
+							} else {
+								Debug.trace("Missing configuration for " + varName);
+							}
+							continue;
+						}
+
+						if (varName.equals(TigaseConfigConst.AUTH_HANDLE)) {
+							if (props.getProperty(name) != null) {
+								idata.setVariable(TigaseConfigConst.AUTH_HANDLE,
+									props.getProperty(name));
+								Debug.trace("Loaded: " + varName + " = " + props.getProperty(name));
+							} else {
+								Debug.trace("Missing configuration for " + varName);
+							}
+							continue;
+						}
+
+						if (varName.equals(TigaseConfigConst.MUC_COMP)) {
+							if ((props.getProperty("--comp-name-1") != null
+									&& props.getProperty("--comp-name-1").equals("muc"))
+								|| (props.getProperty("--comp-name-2") != null
+									&& props.getProperty("--comp-name-2").equals("muc"))) {
+									idata.setVariable(TigaseConfigConst.MUC_COMP, "on");
+							}
+								Debug.trace("Loaded: " + varName + " = " +
+									idata.getVariable(TigaseConfigConst.MUC_COMP));
+							continue;
+						}
+
+						if (varName.equals(TigaseConfigConst.PUBSUB_COMP)) {
+							if ((props.getProperty("--comp-name-1") != null
+									&& props.getProperty("--comp-name-1").equals("pubsub"))
+								|| (props.getProperty("--comp-name-2") != null
+									&& props.getProperty("--comp-name-2").equals("pubsub"))) {
+									idata.setVariable(TigaseConfigConst.PUBSUB_COMP, "on");
+							}
+							Debug.trace("Load: " + "--comp-name-" + " = " + "pubsub");
+							continue;
+						}
+
+						if (varName.equals(TigaseConfigConst.AUTH_DB_URI)) {
+							if (props.getProperty(name) != null) {
+								parseAuthDbUri(props.getProperty(name), idata);
+								Debug.trace("Loaded: " + varName + " = " + props.getProperty(name));
+							} else {
+								Debug.trace("Missing configuration for " + varName);
+							}
+							continue;
+						}
+
+						if (props.getProperty(name) != null) {
+							idata.setVariable(varName, props.getProperty(name));
+						}
+					}
+				}
+				Debug.trace("Done.");
+			} else {
+				config.append("The config file: " + configPath + " seems to not exist...");
+			}
+		} catch (Exception err) {
+			StringBuilder errorConfig = new StringBuilder();
+			errorConfig.append("Error : could not load the config file: " + configPath + "\n");
+			errorConfig.append(err.toString() + "\n");
+			for (StackTraceElement ste: err.getStackTrace()) {
+				errorConfig.append(ste.toString() + "\n");
+			}
+			return errorConfig.toString();
+		}
+		return config.toString();
+	}
+
+	private void parseDebugs(String debugs, AutomatedInstallData idata) {
+		String[] ardebugs = debugs.split(",");
+		Set<String> knownDebugs = TigaseConfigConst.debugMap.keySet();
+		for (String debug: ardebugs) {
+			if (knownDebugs.contains(debug)) {
+				idata.setVariable(TigaseConfigConst.debugMap.get(debug), debug);
+			}
+		}
+	}
+
+	private void parsePlugins(String plugins, AutomatedInstallData idata) {
+		String[] arplugins = plugins.split(",");
+		Set<String> knownPlugins = TigaseConfigConst.pluginsMap.keySet();
+		for (String plugin: arplugins) {
+			if (knownPlugins.contains(plugin)) {
+				idata.setVariable(TigaseConfigConst.pluginsMap.get(plugin), plugin);
+			}
+		}
+	}
+
+	private static Pattern dbUriPattern =
+    Pattern.compile(
+			"jdbc:([^:]+(:[^:]+)?):(//([^/]+))?/?([0-9.a-zA-Z_/-]+)[;\\?]?(user=([^;&]+))?[;&]?(password=([^;&]+))?[;&]?(.*)");
+
+	private void parseUserDbUri(String dbUri, AutomatedInstallData idata) {
+		Matcher m = dbUriPattern.matcher(dbUri);
+		if (m.matches()) {
+			String jdbcDriver = m.group(1);
+			String host = m.group(4);
+			String dbName = m.group(5);
+			String userName = m.group(7);
+			String userPass = m.group(9);
+			String otherPars = m.group(10);
+// 		idata.setVariable(TigaseConfigConst.DB_TYPE,
+// 			TigaseConfigConst.userDBUriMap.get(jdbcDriver));
+			if (jdbcDriver.equals("mysql")) {
+				idata.setVariable("dbSuperuser", "root");
+			}
+			if (jdbcDriver.equals("postgresql")) {
+				idata.setVariable("dbSuperuser", "postgres");
+			}
+			if (host != null) {
+				idata.setVariable("dbHost", host);
+			}
+			if (dbName != null) {
+				if (jdbcDriver.equals("derby")) {
+					idata.setVariable("DerbyDBPath", "/" + dbName);
+					Debug.trace("DerbyDBPath set to /" + dbName);
+				} else {
+					idata.setVariable("dbName", dbName);
+					Debug.trace("dbName read: " + dbName);
+				}
+			}
+			if (userName != null) {
+				idata.setVariable("dbUser", userName);
+			}
+			if (userPass != null) {
+				idata.setVariable("dbPass", userPass);
+			}
+			if (otherPars != null) {
+				idata.setVariable("dbParams", otherPars);
+			}
+		} else {
+			Debug.trace("Hm, the dbUri doesn't match regex: " + dbUri);
+		}
+	}
+
+	private void parseAuthDbUri(String dbUri, AutomatedInstallData idata) {
+		Matcher m = dbUriPattern.matcher(dbUri);
+		if (m.matches()) {
+			String jdbcDriver = m.group(1);
+			String host = m.group(4);
+			String dbName = m.group(5);
+			String userName = m.group(7);
+			String userPass = m.group(9);
+			String otherPars = m.group(10);
+			if (jdbcDriver != null) {
+				idata.setVariable("dbAuthType", jdbcDriver);
+			}
+			if (host != null) {
+				idata.setVariable("dbAuthHost", host);
+			}
+			if (dbName != null) {
+				idata.setVariable("dbAuthName", dbName);
+			}
+			if (userName != null) {
+				idata.setVariable("dbAuthUser", userName);
+			}
+			if (userPass != null) {
+				idata.setVariable("dbAuthPass", userPass);
+			}
+			if (otherPars != null) {
+				idata.setVariable("dbAuthParams", otherPars);
+			}
+		} else {
+			Debug.trace("Hm, the dbAuthUri doesn't match regex: " + dbUri);
+		}
+	}
+	
+}
diff --git a/src/lib/com/izforge/izpack/panels/TigaseConfigLoadPanelConsoleHelper.java b/src/lib/com/izforge/izpack/panels/TigaseConfigLoadPanelConsoleHelper.java
new file mode 100644
index 0000000..8b418b1
--- /dev/null
+++ b/src/lib/com/izforge/izpack/panels/TigaseConfigLoadPanelConsoleHelper.java
@@ -0,0 +1,29 @@
+package com.izforge.izpack.panels;
+
+import java.io.PrintWriter;
+import java.util.Properties;
+
+import com.izforge.izpack.installer.AutomatedInstallData;
+import com.izforge.izpack.installer.PanelConsole;
+import com.izforge.izpack.installer.PanelConsoleHelper;
+
+public class TigaseConfigLoadPanelConsoleHelper  extends PanelConsoleHelper implements PanelConsole {
+
+	public boolean runConsole(AutomatedInstallData installData) {
+		new TigaseConfigLoadHelper().loadConfig(installData);
+		return true;
+	}
+
+	public boolean runConsoleFromPropertiesFile(
+			AutomatedInstallData installData, Properties p) {
+		new TigaseConfigLoadHelper().loadConfig(installData);
+		return true;
+	}
+
+	public boolean runGeneratePropertiesFile(AutomatedInstallData installData,
+			PrintWriter printWriter) {
+		new TigaseConfigLoadHelper().loadConfig(installData);
+		return true;
+	}
+
+}
diff --git a/src/lib/com/izforge/izpack/panels/TigaseConfigSavePanel.java b/src/lib/com/izforge/izpack/panels/TigaseConfigSavePanel.java
new file mode 100644
index 0000000..05cd89b
--- /dev/null
+++ b/src/lib/com/izforge/izpack/panels/TigaseConfigSavePanel.java
@@ -0,0 +1,414 @@
+/*
+ * Tigase Jabber/XMPP Server
+ * Copyright (C) 2004-2012 "Artur Hefczyc" <artur.hefczyc@tigase.org>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. Look for COPYING file in the top folder.
+ * If not, see http://www.gnu.org/licenses/.
+ *
+ * $Rev$
+ * Last modified by $Author$
+ * $Date$
+ */
+
+package com.izforge.izpack.panels;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.util.Map;
+import java.util.Properties;
+
+import javax.swing.JScrollPane;
+import javax.swing.JTextArea;
+
+import com.izforge.izpack.gui.IzPanelLayout;
+import com.izforge.izpack.installer.AutomatedInstallData;
+import com.izforge.izpack.installer.InstallData;
+import com.izforge.izpack.installer.InstallerFrame;
+import com.izforge.izpack.installer.IzPanel;
+import com.izforge.izpack.util.Debug;
+import com.izforge.izpack.util.OsVersion;
+
+/**
+ * The Hello panel class.
+ *
+ * @author <a href="mailto:artur.hefczyc@tigase.org">Artur Hefczyc</a>
+ * @version $Rev$
+ */
+public class TigaseConfigSavePanel extends IzPanel {
+
+	/**
+	 *
+	 */
+	private static final long serialVersionUID = 1L;
+
+	private JTextArea textArea = null;
+
+	private final TigaseConfigSaveHelper helper = new TigaseConfigSaveHelper();
+
+
+	/**
+	 * The constructor.
+	 *
+	 * @param parent The parent.
+	 * @param idata  The installation data.
+	 */
+	public TigaseConfigSavePanel(InstallerFrame parent, InstallData idata) {
+		super(parent, TigaseInstallerCommon.init(idata), new IzPanelLayout());
+
+		// The config label.
+		String msg = parent.langpack.getString("TigaseConfigSavePanel.info");
+		add(createMultiLineLabel(msg));
+		add(IzPanelLayout.createParagraphGap());
+		// The text area which shows the info.
+		textArea = new JTextArea("");
+		textArea.setCaretPosition(0);
+		textArea.setEditable(true);
+		JScrollPane scroller = new JScrollPane(textArea);
+		add(scroller, NEXT_LINE);
+		// At end of layouting we should call the completeLayout method also they do nothing.
+		getLayoutHelper().completeLayout();
+	}
+
+	public void panelActivate() {
+		super.panelActivate();
+		String config = helper.showConfig(
+				new IzPackInstallDataVariablesSource(idata));
+		textArea.setText(config);
+	}
+
+
+
+	/**
+	 * Indicates wether the panel has been validated or not.
+	 *
+	 * @return Always true.
+	 */
+	public boolean isValidated() {
+		String errorStr =  helper.saveConfig(idata, textArea.getText());
+		if (errorStr != null) {
+			emitError("Can not write to config file", errorStr);
+		}
+		return true;
+	}
+
+}
+
+abstract class VariablesSource {
+	abstract String getVariable(String key);
+}
+
+class IzPackInstallDataVariablesSource extends VariablesSource {
+	private final AutomatedInstallData idata;
+
+	public IzPackInstallDataVariablesSource(AutomatedInstallData idata) {
+		this.idata = idata;
+		
+	}
+
+	@Override
+	String getVariable(String key) {
+		return idata.getVariable(key);
+	}
+}
+
+class TigaseConfigSaveHelper {
+	
+	String showConfig(VariablesSource variablesSource) {
+		TigaseConfigConst.props = new Properties();
+		StringBuilder config = new StringBuilder();
+		int comp_idx = 0;
+		for (Map.Entry<String, String> entry:
+        TigaseConfigConst.tigaseIzPackMap.entrySet()) {
+			String varName = entry.getValue();
+			String varValue = variablesSource.getVariable(varName);
+
+			if (varName.equals(TigaseConfigConst.DEBUG)) {
+				String debugVar = getDebugs(variablesSource);
+				if (!debugVar.isEmpty()) {
+					TigaseConfigConst.props.setProperty(entry.getKey(), debugVar);
+				}
+				Debug.trace("Set: " + entry.getKey() + " = " + debugVar);
+				continue;
+			}
+			if (varName.equals(TigaseConfigConst.PLUGINS)) {
+				String pluginsVar = getPlugins(variablesSource);
+				if (!pluginsVar.isEmpty()) {
+					TigaseConfigConst.props.setProperty(entry.getKey(), pluginsVar);
+				}
+				Debug.trace("Set: " + entry.getKey() + " = " + pluginsVar);
+				continue;
+			}
+			if (varName.equals(TigaseConfigConst.USER_DB_URI)) {
+				TigaseConfigConst.props.setProperty(entry.getKey(), getDBUri(variablesSource));
+				TigaseConfigConst.props.setProperty("root-tigase-db-uri",
+					getRootTigaseDBUri(variablesSource));
+				TigaseConfigConst.props.setProperty("root-db-uri", getRootDBUri(variablesSource));
+				Debug.trace("Set: " + entry.getKey() + " = " + getDBUri(variablesSource));
+				continue;
+			}
+
+			if (varValue == null) continue;
+
+			if (varName.equals(TigaseConfigConst.DB_TYPE)) {
+				TigaseConfigConst.props.setProperty(entry.getKey(), getUserDB(variablesSource));
+				Debug.trace("Set: " + entry.getKey() + " = " + getUserDB(variablesSource));
+				continue;
+			}
+			if (varName.equals(TigaseConfigConst.AUTH_HANDLE)) {
+				TigaseConfigConst.props.setProperty(entry.getKey(),
+					getAuthHandler(varValue, variablesSource));
+				Debug.trace("Set: " + entry.getKey() + " = " + getAuthHandler(varValue, variablesSource));
+				continue;
+			}
+			if (varName.equals(TigaseConfigConst.MUC_COMP)) {
+				if (varValue.equals("on")) {
+					++comp_idx;
+					TigaseConfigConst.props.setProperty("--comp-name-"+comp_idx, "muc");
+					TigaseConfigConst.props.setProperty("--comp-class-"+comp_idx,
+						"tigase.muc.MUCComponent");
+				}
+				Debug.trace("Set: " + "--comp-name-"+comp_idx + " = " + "muc");
+				continue;
+			}
+			if (varName.equals(TigaseConfigConst.PUBSUB_COMP)) {
+				if (varValue.equals("on")) {
+					++comp_idx;
+					TigaseConfigConst.props.setProperty("--comp-name-"+comp_idx, "pubsub");
+					TigaseConfigConst.props.setProperty("--comp-class-"+comp_idx,
+						"tigase.pubsub.PubSubClusterComponent");
+				}
+				Debug.trace("Set: " + "--comp-name-"+comp_idx + " = " + "pubsub");
+				continue;
+			}
+			if (varName.equals(TigaseConfigConst.AUTH_DB_URI)) {
+				String auth_db_uri = getAuthUri(variablesSource);
+				if (auth_db_uri != null) {
+					TigaseConfigConst.props.setProperty(entry.getKey(), auth_db_uri);
+					Debug.trace("Set: " + entry.getKey() + " = " + auth_db_uri);
+				} else {
+					Debug.trace("Not set: " + entry.getKey());
+				}
+				continue;
+			}
+			if (!varValue.trim().isEmpty()) {
+				TigaseConfigConst.props.setProperty(entry.getKey(), varValue);
+			}
+			Debug.trace("Set: " + entry.getKey() + " = " + varValue);
+		}
+		for (String name: TigaseConfigConst.props.stringPropertyNames()) {
+			if (!name.startsWith("root")) {
+				config.append(name + " = " + TigaseConfigConst.props.getProperty(name) + "\n");
+			}
+		}
+		return config.toString();
+	}
+
+	private String getDBUri(VariablesSource variablesSource) {
+		String db_uri = "jdbc:";
+		String database = getUserDB(variablesSource);
+		if (database.equals("pgsql")) {
+			db_uri += "postgresql:";
+		} else {
+			db_uri += database + ":";
+		}
+		if (database.equals("derby")) {
+			String derby_path = variablesSource.getVariable("DerbyDBPath");
+			if (OsVersion.IS_WINDOWS && derby_path != null) {
+				derby_path = derby_path.replace("\\", "\\\\");
+			}
+			db_uri += derby_path;
+		} else {
+			db_uri += "//" + variablesSource.getVariable("dbHost");
+			db_uri += "/" + variablesSource.getVariable("dbName");
+			db_uri += "?user=" + variablesSource.getVariable("dbUser");
+			if (variablesSource.getVariable("dbPass") != null
+				&& !variablesSource.getVariable("dbPass").isEmpty()) {
+				db_uri += "&password=" + variablesSource.getVariable("dbPass");
+			}
+		}
+		return db_uri;
+	}
+
+	private String getRootTigaseDBUri(VariablesSource variablesSource) {
+		String db_uri = "jdbc:";
+		String database = getUserDB(variablesSource);
+		if (database.equals("pgsql")) {
+			db_uri += "postgresql:";
+		} else {
+			db_uri += database + ":";
+		}
+		if (database.equals("derby")) {
+			db_uri += variablesSource.getVariable("DerbyDBPath") + ";create=true";
+		} else {
+			db_uri += "//" + variablesSource.getVariable("dbHost");
+			db_uri += "/" + variablesSource.getVariable("dbName");
+			db_uri += "?user=" + variablesSource.getVariable("dbSuperuser");
+			if (variablesSource.getVariable("dbSuperpass") != null
+				&& !variablesSource.getVariable("dbSuperpass").isEmpty()) {
+				db_uri += "&password=" + variablesSource.getVariable("dbSuperpass");
+			}
+		}
+		return db_uri;
+	}
+
+	private String getRootDBUri(VariablesSource variablesSource) {
+		String db_uri = "jdbc:";
+		String db = "";
+		String database = getUserDB(variablesSource);
+		if (database.equals("pgsql")) {
+			db_uri += "postgresql:";
+			db = "/postgres";
+		} else {
+			db_uri += database + ":";
+			if (database.equals("mysql")) {
+				db = "/mysql";
+			}
+		}
+		if (database.equals("derby")) {
+			db_uri += variablesSource.getVariable("DerbyDBPath") + ";create=true";
+		} else {
+			db_uri += "//" + variablesSource.getVariable("dbHost");
+			db_uri += db;
+			db_uri += "?user=" + variablesSource.getVariable("dbSuperuser");
+			if (variablesSource.getVariable("dbSuperpass") != null
+				&& !variablesSource.getVariable("dbSuperpass").isEmpty()) {
+				db_uri += "&password=" + variablesSource.getVariable("dbSuperpass");
+			}
+		}
+		return db_uri;
+	}
+
+	private String getAuthUri(VariablesSource variablesSource) {
+		String db_uri = "jdbc:";
+		String database = variablesSource.getVariable(TigaseConfigConst.AUTH_DB_URI);
+		db_uri += database + ":";
+		if (database.equals("derby")) {
+			String derby_path = variablesSource.getVariable("DerbyDBPath");
+			if (derby_path != null) {
+				db_uri += derby_path;
+			} else {
+				return null;
+			}
+		} else {
+			db_uri += "//" + variablesSource.getVariable("dbAuthHost");
+			db_uri += "/" + variablesSource.getVariable("dbAuthName");
+			db_uri += "?user=" + variablesSource.getVariable("dbAuthUser");
+			if (variablesSource.getVariable("dbAuthPass") != null
+				&& !variablesSource.getVariable("dbAuthPass").isEmpty()) {
+				db_uri += "&password=" + variablesSource.getVariable("dbAuthPass");
+			}
+		}
+		return db_uri;
+	}
+
+	private String getPlugins(VariablesSource variablesSource) {
+		String plugins = "";
+		if (variablesSource.getVariable(TigaseConfigConst.ALL_PLUGINS[0]) == null) {
+			// The Panel with debuging settings was not shown so all
+			// settins are null, then we set a default: 'server'
+			return "";
+		}
+		for (String plugin: TigaseConfigConst.ALL_PLUGINS) {
+			if (variablesSource.getVariable(plugin) == null) {
+				Debug.trace("Missing variables for: " + plugin);
+				continue;
+			}
+			
+			final String value = variablesSource.getVariable(plugin);
+			final String prefix;
+			final String pluginId = TigaseConfigConst.getPluginId(plugin);
+			if (value.equals("off")) {
+				prefix = "-";
+			} else {
+				prefix = "+";
+			} 
+			
+			if (!plugins.isEmpty()) {
+				plugins += ",";
+			}
+			plugins += prefix + pluginId;
+		}
+		
+		return plugins;
+	}
+
+	private String getDebugs(VariablesSource variablesSource) {
+
+		String debugs = "";
+		if (variablesSource.getVariable(TigaseConfigConst.ALL_DEBUGS[0]) == null) {
+			// The Panel with debuging settings was not shown so all
+			// settins are null, then we set a default: 'server'
+			return "server";
+		}
+		for (String deb: TigaseConfigConst.ALL_DEBUGS) {
+			if (variablesSource.getVariable(deb) == null 
+					|| variablesSource.getVariable(deb).equals("off")) {
+				continue;
+			}
+			if (!debugs.isEmpty()) {
+				debugs += ",";
+			}
+			debugs += variablesSource.getVariable(deb);
+		}
+		return debugs;
+	}
+
+	private String getAuthHandler(String var, VariablesSource variablesSource) {
+		if (var.equals("Standard")) {
+			return getUserDB(variablesSource);
+		}
+		return var;
+	}
+
+	private String getUserDB(VariablesSource variablesSource) {
+		String dbVar = variablesSource.getVariable(TigaseConfigConst.DB_TYPE);
+		String result = TigaseConfigConst.userDBMap.get(dbVar);
+		return result != null ? result : "derby";
+	}
+	
+	// returns null if ok, error string on error
+	String saveConfig(AutomatedInstallData variablesSource, String config) {
+		// Try to read the config file.
+		File configPath = null;
+		File xmlConfigPath = null;
+		try {
+			if (variablesSource.getVariable("searchTigaseHome") == null
+				|| variablesSource.getVariable("searchTigaseHome").isEmpty()) {
+				configPath = new File(variablesSource.getVariable("INSTALL_PATH"),
+					"etc/init.properties");
+				xmlConfigPath = new File(variablesSource.getVariable("INSTALL_PATH"),
+					"etc/tigase.xml");
+			} else {
+				configPath = new File(variablesSource.getVariable("searchTigaseHome"),
+					"etc/init.properties");
+				xmlConfigPath = new File(variablesSource.getVariable("searchTigaseHome"),
+					"etc/tigase.xml");
+			}
+			FileWriter fw = new FileWriter(configPath, false);
+			fw.write(config);
+			fw.close();
+			if (xmlConfigPath.exists()) {
+				xmlConfigPath.delete();
+			}
+		} catch (Exception err) {
+			String error = "Error : could not write to the config file: " + configPath + "\n";
+			error += err.toString() + "\n";
+			for (StackTraceElement ste: err.getStackTrace()) {
+				error += ste.toString() + "\n";
+			}
+			return error;
+		}
+		return null;
+	}
+
+}
\ No newline at end of file
diff --git a/src/lib/com/izforge/izpack/panels/TigaseConfigSavePanelConsoleHelper.java b/src/lib/com/izforge/izpack/panels/TigaseConfigSavePanelConsoleHelper.java
new file mode 100644
index 0000000..1858e6f
--- /dev/null
+++ b/src/lib/com/izforge/izpack/panels/TigaseConfigSavePanelConsoleHelper.java
@@ -0,0 +1,35 @@
+package com.izforge.izpack.panels;
+
+import java.io.PrintWriter;
+import java.util.Properties;
+
+import com.izforge.izpack.installer.AutomatedInstallData;
+import com.izforge.izpack.installer.PanelConsole;
+import com.izforge.izpack.installer.PanelConsoleHelper;
+
+public class TigaseConfigSavePanelConsoleHelper  
+extends PanelConsoleHelper implements PanelConsole {
+
+	public boolean runConsole(AutomatedInstallData installData) {
+		TigaseConfigSaveHelper helper = new TigaseConfigSaveHelper();
+		
+		String config =  helper.showConfig(
+				new IzPackInstallDataVariablesSource(installData));
+		helper.saveConfig(installData, config);
+		
+		return true;
+	}
+
+	
+	
+	public boolean runConsoleFromPropertiesFile(
+			AutomatedInstallData installData, Properties p) {
+		return false;
+	}
+
+	public boolean runGeneratePropertiesFile(AutomatedInstallData installData,
+			PrintWriter printWriter) {
+		return false;
+	}
+
+}
diff --git a/src/lib/com/izforge/izpack/panels/TigaseDBCheckPanel.java b/src/lib/com/izforge/izpack/panels/TigaseDBCheckPanel.java
new file mode 100644
index 0000000..dd0cc46
--- /dev/null
+++ b/src/lib/com/izforge/izpack/panels/TigaseDBCheckPanel.java
@@ -0,0 +1,160 @@
+/*
+ * Tigase Jabber/XMPP Server
+ * Copyright (C) 2004-2012 "Artur Hefczyc" <artur.hefczyc@tigase.org>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. Look for COPYING file in the top folder.
+ * If not, see http://www.gnu.org/licenses/.
+ *
+ * $Rev$
+ * Last modified by $Author$
+ * $Date$
+ */
+
+package com.izforge.izpack.panels;
+
+import java.util.Timer;
+import java.util.TimerTask;
+
+import javax.swing.JScrollPane;
+import javax.swing.JTable;
+import javax.swing.SwingUtilities;
+import javax.swing.table.AbstractTableModel;
+import javax.swing.table.TableModel;
+
+import com.izforge.izpack.gui.IzPanelLayout;
+import com.izforge.izpack.installer.InstallData;
+import com.izforge.izpack.installer.InstallerFrame;
+import com.izforge.izpack.installer.IzPanel;
+import com.izforge.izpack.panels.TigaseInstallerDBHelper.MsgTarget;
+import com.izforge.izpack.panels.TigaseInstallerDBHelper.ResultMessage;
+import com.izforge.izpack.panels.TigaseInstallerDBHelper.TigaseDBTask;
+
+/**
+ * The Hello panel class.
+ *
+ * @author <a href="mailto:artur.hefczyc@tigase.org">Artur Hefczyc</a>
+ * @version $Rev$
+ */
+public class TigaseDBCheckPanel extends IzPanel {
+
+	/**
+	 *
+	 */
+	private static final long serialVersionUID = 1L;
+
+	private JTable table = null;
+	private Timer delayedTasks = new Timer("DelayedTasks", true);
+
+	private final InstallData idata;
+
+	/**
+	 * The constructor.
+	 *
+	 * @param parent The parent.
+	 * @param idata  The installation data.
+	 */
+	public TigaseDBCheckPanel(InstallerFrame parent, InstallData idata) {
+		super(parent, TigaseInstallerCommon.init(idata), new IzPanelLayout());
+		this.idata = idata;
+
+		// The config label.
+		String msg = parent.langpack.getString("TigaseDBCheckPanel.info");
+		add(createMultiLineLabel(msg));
+		add(IzPanelLayout.createParagraphGap());
+
+		final String[] columnNames = new String[] {"Action", "Result"};
+		
+		TigaseDBTask[] tasks = TigaseInstallerDBHelper.Tasks.getTasksInOrder();
+		final String[][] data = new String[tasks.length][];
+		for (int i = 0 ; i < tasks.length ; i++) {
+			TigaseDBTask task = tasks[i];
+			data[i] = new String[] { task.getDescription(), "" };
+		}
+		
+		TableModel dataModel = new AbstractTableModel() {
+//				private String[] columnNames = names;
+//				private Object[][] data = datas;
+				public int getColumnCount() { return columnNames.length; }
+				public int getRowCount() { return data.length; }
+				public String getColumnName(int col) { return columnNames[col]; }
+				public Object getValueAt(int row, int col) { return data[row][col]; }
+				public Class getColumnClass(int c) { return getValueAt(0, c).getClass(); }
+				public boolean isCellEditable(int row, int col) { return false; }
+				public void setValueAt(Object value, int row, int col) {
+					data[row][col] = value.toString();
+					fireTableCellUpdated(row, col);
+				}
+      };
+		// The table area which shows the info.
+		table = new JTable(dataModel);
+		//		table.setEditable(false);
+		//add(table, NEXT_LINE);
+		JScrollPane scroller = new JScrollPane(table);
+		table.setFillsViewportHeight(true);
+		add(scroller, NEXT_LINE);
+		// At end of layouting we should call the completeLayout
+		// method also they do nothing.
+		getLayoutHelper().completeLayout();
+	}
+
+	public void panelActivate() {
+		super.panelActivate();
+		parent.lockNextButton();
+		
+		final TigaseInstallerDBHelper dbHelper = new TigaseInstallerDBHelper();
+		
+		delayedTasks.schedule(new TimerTask() {
+				
+			public void run() {
+				TigaseDBTask[] tasks = TigaseInstallerDBHelper.Tasks.getTasksInOrder();
+				
+				for (int i = 0 ; i < tasks.length ; i++) {
+					TigaseDBTask task = tasks[i];
+					final int row = i;
+					
+					MsgTarget msgTarget = new MsgTarget() {
+						public ResultMessage addResultMessage() {
+							return new ResultMessage() {
+								private String fullMsg = "";
+
+								public void append(String msg) {
+									fullMsg += msg;
+									SwingUtilities.invokeLater(new Runnable() {
+										public void run() {
+											table.getModel().setValueAt(fullMsg, row, 1);
+										}
+									});
+								}
+							};
+						}
+					};
+						
+					task.execute(dbHelper, idata.getVariables(), msgTarget);
+				}
+				parent.unlockNextButton();
+			}
+		}, 500);
+	}
+
+	/**
+	 * Indicates wether the panel has been validated or not.
+	 *
+	 * @return Always true.
+	 */
+	public boolean isValidated() {
+		return true;
+	}
+
+}
+
+
diff --git a/src/lib/com/izforge/izpack/panels/TigaseDBCheckPanelConsoleHelper.java b/src/lib/com/izforge/izpack/panels/TigaseDBCheckPanelConsoleHelper.java
new file mode 100644
index 0000000..101e248
--- /dev/null
+++ b/src/lib/com/izforge/izpack/panels/TigaseDBCheckPanelConsoleHelper.java
@@ -0,0 +1,62 @@
+package com.izforge.izpack.panels;
+
+import java.io.PrintWriter;
+import java.util.Properties;
+
+import com.izforge.izpack.installer.AutomatedInstallData;
+import com.izforge.izpack.installer.ConsoleInstallHelper;
+import com.izforge.izpack.installer.PanelConsole;
+import com.izforge.izpack.installer.PanelConsoleHelper;
+import com.izforge.izpack.panels.TigaseInstallerDBHelper.ResultMessage;
+import com.izforge.izpack.panels.TigaseInstallerDBHelper.TigaseDBTask;
+
+public class TigaseDBCheckPanelConsoleHelper extends PanelConsoleHelper implements PanelConsole {
+
+	private ConsoleInstallHelper helper = ConsoleInstallHelper.getInstance();
+	
+	public boolean runConsole(AutomatedInstallData installData) {
+		
+		TigaseInstallerDBHelper dbHelper = new TigaseInstallerDBHelper();
+	
+		helper.console.displayLabel("Performing DB tasks");
+				
+		for (TigaseDBTask task : TigaseInstallerDBHelper.Tasks.getTasksInOrder()) {
+			helper.console.displayEmptyLine();
+			helper.console.displayRaw(task.getDescription() + "  ");
+			
+			TigaseInstallerDBHelper.MsgTarget msgTarget = new TigaseInstallerDBHelper.MsgTarget() {
+				public ResultMessage addResultMessage() {
+					helper.console.displayEmptyLine();
+					return new ResultMessage() {
+						public void append(String msg) {
+							helper.console.displayRaw(msg);
+						}
+					};
+				}
+			};
+
+			task.execute(dbHelper, installData.getVariables(), msgTarget);
+		}
+		
+		helper.console.displayEmptyLine();
+		helper.console.displayEmptyLine();
+		helper.console.displayEmptyLine();
+
+		return true;
+	}
+
+
+	
+	// not implemented
+	
+	public boolean runConsoleFromPropertiesFile(
+			AutomatedInstallData installData, Properties p) {
+		return false;
+	}
+
+	public boolean runGeneratePropertiesFile(AutomatedInstallData installData,
+			PrintWriter printWriter) {
+		return false;
+	}
+
+}
diff --git a/src/lib/com/izforge/izpack/panels/TigaseInstallerDbHelperFunctionalTest.java b/src/lib/com/izforge/izpack/panels/TigaseInstallerDbHelperFunctionalTest.java
new file mode 100644
index 0000000..f1d2afb
--- /dev/null
+++ b/src/lib/com/izforge/izpack/panels/TigaseInstallerDbHelperFunctionalTest.java
@@ -0,0 +1,39 @@
+package com.izforge.izpack.panels;
+
+import java.util.Properties;
+
+import com.izforge.izpack.panels.TigaseInstallerDBHelper.MsgTarget;
+import com.izforge.izpack.panels.TigaseInstallerDBHelper.ResultMessage;
+import com.izforge.izpack.panels.TigaseInstallerDBHelper.TigaseDBTask;
+
+public class TigaseInstallerDbHelperFunctionalTest {
+
+	public static void main(String[] args) {
+		testPostgres();
+	}
+
+	private static void testPostgres() {
+		
+		TigaseInstallerDBHelper helper = new TigaseInstallerDBHelper();
+		Properties variables = new Properties();
+		
+		for (final TigaseDBTask task : 
+			TigaseInstallerDBHelper.Tasks.getTasksInOrder()) 
+		{
+			MsgTarget msgTarget = new MsgTarget() {
+				public ResultMessage addResultMessage() {
+					System.err.println("Task: " + task.getDescription());
+					return new ResultMessage() {
+						public void append(String msg) {
+							System.err.print(msg);
+						}
+					};
+				}
+			};
+			
+			task.execute(helper, variables, msgTarget);
+		}
+		
+	}
+	
+}
diff --git a/src/lib/com/izforge/izpack/panels/UserInputPanel.java b/src/lib/com/izforge/izpack/panels/UserInputPanel.java
index fbda7e9..5e46d4e 100644
--- a/src/lib/com/izforge/izpack/panels/UserInputPanel.java
+++ b/src/lib/com/izforge/izpack/panels/UserInputPanel.java
@@ -2456,6 +2456,8 @@ public class UserInputPanel extends IzPanel implements ActionListener, ItemListe
                 if (value.equals(trueValue))
                 {
                     set = TRUE;
+                } else {
+                	set = FALSE;
                 }
             }
         }
diff --git a/src/lib/com/izforge/izpack/panels/UserInputPanel.java b/src/lib/com/izforge/izpack/panels/UserInputPanel.java
index 73b9c58..308941f 100644
--- a/src/lib/com/izforge/izpack/panels/UserInputPanel.java
+++ b/src/lib/com/izforge/izpack/panels/UserInputPanel.java
@@ -69,10 +69,7 @@ import com.izforge.izpack.gui.ButtonFactory;
 import com.izforge.izpack.gui.LabelFactory;
 import com.izforge.izpack.gui.TwoColumnConstraints;
 import com.izforge.izpack.gui.TwoColumnLayout;
-import com.izforge.izpack.installer.InstallData;
-import com.izforge.izpack.installer.InstallerFrame;
-import com.izforge.izpack.installer.IzPanel;
-import com.izforge.izpack.installer.ResourceManager;
+import com.izforge.izpack.installer.*;
 import com.izforge.izpack.rules.RulesEngine;
 import com.izforge.izpack.rules.VariableExistenceCondition;
 import com.izforge.izpack.util.Debug;
@@ -372,11 +369,16 @@ public class UserInputPanel extends IzPanel implements ActionListener, ItemListe
             String resource = LANG_FILE_NAME + "_" + idata.localeISO3;
             this.langpack.add(ResourceManager.getInstance().getInputStream(resource));
         }
-        catch (Throwable exception)
+        catch (ResourceNotFoundException e)
         {
-            exception.printStackTrace();
+            Debug.trace(e);
+        }
+        catch (Exception e)
+        {
+            e.printStackTrace();
         }
 
+
         // ----------------------------------------------------
         // read the specifications
         // ----------------------------------------------------
diff --git a/src/lib/com/izforge/izpack/panels/UserInputPanelConsoleHelper.java b/src/lib/com/izforge/izpack/panels/UserInputPanelConsoleHelper.java
index ca9a659..1245897 100644
--- a/src/lib/com/izforge/izpack/panels/UserInputPanelConsoleHelper.java
+++ b/src/lib/com/izforge/izpack/panels/UserInputPanelConsoleHelper.java
@@ -25,6 +25,7 @@ import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.PrintWriter;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Properties;
@@ -33,6 +34,8 @@ import java.util.Vector;
 import com.izforge.izpack.Panel;
 import com.izforge.izpack.adaptator.IXMLElement;
 import com.izforge.izpack.installer.AutomatedInstallData;
+import com.izforge.izpack.installer.ConsoleHelper;
+import com.izforge.izpack.installer.ConsoleInstallHelper;
 import com.izforge.izpack.installer.PanelConsole;
 import com.izforge.izpack.installer.PanelConsoleHelper;
 import com.izforge.izpack.util.Debug;
@@ -68,6 +71,8 @@ public class UserInputPanelConsoleHelper extends PanelConsoleHelper implements P
     private static final String SET = "set";
 
     private static final String TEXT = "txt";
+    
+    private static final String ID = "id";
 
     private static final String SPEC = "spec";
 
@@ -78,16 +83,28 @@ public class UserInputPanelConsoleHelper extends PanelConsoleHelper implements P
     private static final String COMBO_FIELD = "combo";
 
     private static final String STATIC_TEXT = "staticText";
-
+    
+    private static final String TITLE_TEXT = "title";
+
+    private static final String SPACE_TEXT = "space";
+    
+    private static final String DIVIDER_TEXT = "divider";
+    
+    private static final String CHECK_FIELD = "check";
+    
     private static final String CHOICE = "choice";
 
     private static final String VALUE = "value";
 
     private static final String RADIO_FIELD = "radio";
+    
+    private static final String PASSWORD_FIELD = "password";
 
     private static final String DESCRIPTION = "description";
 
     private static final String TRUE = "true";
+    
+    private static final String FALSE = "false";
 
     public List<Input> listInputs;
 
@@ -103,7 +120,7 @@ public class UserInputPanelConsoleHelper extends PanelConsoleHelper implements P
         Iterator<Input> inputIterator = listInputs.iterator();
         while (inputIterator.hasNext())
         {
-            String strVariableName = ((Input) inputIterator.next()).strVariableName;
+            String strVariableName = ((Input) inputIterator.next()).getVariableName();
             String strVariableValue = p.getProperty(strVariableName);
             if (strVariableValue != null)
             {
@@ -120,7 +137,7 @@ public class UserInputPanelConsoleHelper extends PanelConsoleHelper implements P
         Iterator<Input> inputIterator = listInputs.iterator();
         while (inputIterator.hasNext())
         {
-            printWriter.println(((Input) inputIterator.next()).strVariableName + "=");
+            printWriter.println(((Input) inputIterator.next()).getVariableName() + "=");
         }
         return true;
     }
@@ -133,37 +150,14 @@ public class UserInputPanelConsoleHelper extends PanelConsoleHelper implements P
         while (inputsIterator.hasNext())
         {
             Input input = inputsIterator.next();
-            String text = input.strText;
-            if (text != null)
-            {
-                System.out.println(text);
-            }
-            if (TEXT_FIELD.equals(input.strFieldType))
-            {
-                status = status && processTextField(input, idata);
-            }
-            else if (COMBO_FIELD.equals(input.strFieldType)
-                    || RADIO_FIELD.equals(input.strFieldType))
-            {
-                status = status && processComboRadioField(input, idata);
-            }
-
-        }
-
-        int i = askEndOfConsolePanel();
-        if (i == 1)
-        {
-            return true;
-        }
-        else if (i == 2)
-        {
-            return false;
-        }
-        else
-        {
-            return runConsole(idata);
+            try {
+				status = status && input.process(idata);
+			} catch (IOException e) {
+				throw new RuntimeException("I/O error", e);
+			} 
         }
 
+        return continueQuitOrReboot(idata, this);
     }
 
     public boolean collectInputs(AutomatedInstallData idata)
@@ -215,147 +209,10 @@ public class UserInputPanelConsoleHelper extends PanelConsoleHelper implements P
             }
             listInputs.add(getInputFromField(field));
         }
+        
         return true;
     }
 
-    boolean processTextField(Input input, AutomatedInstallData idata)
-    {
-        String variable = input.strVariableName;
-        String set;
-        String fieldText;
-        if ((variable == null) || (variable.length() == 0)) { return false; }
-
-        if (input.listChoices.size() == 0)
-        {
-            Debug.trace("Error: no spec element defined in file field");
-            return false;
-        }
-        set = input.strDefaultValue;
-        if (set == null)
-        {
-            set = idata.getVariable(variable);
-            if (set == null)
-            {
-                set = "";
-            }
-        }
-        else
-        {
-            if (set != null && !"".equals(set))
-            {
-
-                VariableSubstitutor vs = new VariableSubstitutor(idata.getVariables());
-                set = vs.substitute(set, null);
-            }
-        }
-
-        fieldText = input.listChoices.get(0).strText;
-        System.out.println(fieldText + " [" + set + "] ");
-        try
-        {
-            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-            String strIn = br.readLine();
-            if (!strIn.trim().equals(""))
-            {
-                idata.setVariable(variable, strIn);
-            }
-            else
-            {
-                idata.setVariable(variable, set);
-            }
-        }
-        catch (IOException e)
-        {
-            e.printStackTrace();
-        }
-        return true;
-
-    }
-
-    boolean processComboRadioField(Input input, AutomatedInstallData idata)
-    {// TODO protection if selection not valid and no set value
-        String variable = input.strVariableName;
-        if ((variable == null) || (variable.length() == 0)) { return false; }
-        String currentvariablevalue = idata.getVariable(variable);
-        boolean userinput = false;
-        List<Choice> lisChoices = input.listChoices;
-        if (lisChoices.size() == 0)
-        {
-            Debug.trace("Error: no spec element defined in file field");
-            return false;
-        }
-        if (currentvariablevalue != null)
-        {
-            userinput = true;
-        }
-        for (int i = 0; i < lisChoices.size(); i++)
-        {
-            Choice choice = lisChoices.get(i);
-            String value = choice.strValue;
-            if (userinput)
-            {
-                if ((value != null) && (value.length() > 0) && (currentvariablevalue.equals(value)))
-                {
-                    input.iSelectedChoice = i;
-                }
-            }
-            else
-            {
-                String set = choice.strSet;
-                if (set != null)
-                {
-                    if (set != null && !"".equals(set))
-                    {
-                        VariableSubstitutor vs = new VariableSubstitutor(idata.getVariables());
-                        set = vs.substitute(set, null);
-                    }
-                    if (set.equals(TRUE))
-                    {
-                        input.iSelectedChoice = i;
-                    }
-                }
-            }
-            System.out.println(i + "  [" + (input.iSelectedChoice == i ? "x" : " ") + "] "
-                    + (choice.strText != null ? choice.strText : ""));
-        }
-
-        try
-        {
-            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-            boolean bKeepAsking = true;
-
-            while (bKeepAsking)
-            {
-                System.out.println("input selection:");
-                String strIn = br.readLine();
-                // take default value if default value exists and no user input
-                if (strIn.trim().equals("") && input.iSelectedChoice != -1)
-                {
-                    bKeepAsking = false;
-                }
-                int j = -1;
-                try
-                {
-                    j = Integer.valueOf(strIn).intValue();
-                }
-                catch (Exception ex)
-                {}
-                // take user input if user input is valid
-                if (j >= 0 && j < lisChoices.size())
-                {
-                    input.iSelectedChoice = j;
-                    bKeepAsking = false;
-                }
-            }
-        }
-        catch (IOException e)
-        {
-            e.printStackTrace();
-        }
-        idata.setVariable(variable, input.listChoices.get(input.iSelectedChoice).strValue);
-        return true;
-
-    }
 
     public Input getInputFromField(IXMLElement field)
     {
@@ -365,11 +222,10 @@ public class UserInputPanelConsoleHelper extends PanelConsoleHelper implements P
         {
             String strText = null;
             strText = field.getAttribute(TEXT);
-            return new Input(strVariableName, null, null, STATIC_TEXT, strText, 0);
+            return new StaticText(strVariableName, strText);
         }
         if (TEXT_FIELD.equals(strFieldType))
         {
-            List<Choice> choicesList = new ArrayList<Choice>();
             String strFieldText = null;
             String strSet = null;
             String strText = null;
@@ -384,9 +240,29 @@ public class UserInputPanelConsoleHelper extends PanelConsoleHelper implements P
             {
                 strFieldText = description.getAttribute(TEXT);
             }
-            choicesList.add(new Choice(strText, null, strSet));
-            return new Input(strVariableName, strSet, choicesList, TEXT_FIELD, strFieldText, 0);
-
+            Choice choice = new Choice(strText, null, strSet);
+            return new Text(strVariableName, true, strSet, choice, strFieldText);
+        }
+        else if (PASSWORD_FIELD.equals(strFieldType)) {
+            IXMLElement spec = field.getFirstChildNamed(SPEC);
+            String pwd1, pwd2;
+            if (spec != null)
+            {
+            	List<IXMLElement> pwdElements = field.getChildrenNamed("pwd");
+            	if (pwdElements.size() != 2) {
+            		throw new RuntimeException("Currently only two pwd values" +
+            				" are supported in a password field");
+            	}
+            	pwd1 = pwdElements.get(0).getAttribute("txt");
+            	pwd2 = pwdElements.get(1).getAttribute("txt");
+            	if (pwd1 == null || pwd2 == null) {
+            		throw new RuntimeException("Pwd elements need to specify " +
+            				"a text attribute in a password field");
+            	}
+            } else {
+            	throw new RuntimeException("Password field needs specification");
+            }
+            return new Password(strVariableName, pwd1, pwd2);
         }
         else if (COMBO_FIELD.equals(strFieldType) || RADIO_FIELD.equals(strFieldType))
         {
@@ -409,44 +285,384 @@ public class UserInputPanelConsoleHelper extends PanelConsoleHelper implements P
                 choicesList.add(new Choice(choice.getAttribute(TEXT), choice.getAttribute(VALUE),
                         choice.getAttribute(SET)));
             }
-            return new Input(strVariableName, null, choicesList, COMBO_FIELD, strFieldText, -1);
+            return new Combo(strVariableName, choicesList, strFieldText);
+            
+//            return new Input(strVariableName, null, choicesList, COMBO_FIELD, strFieldText, -1);
+        } 
+        else if (CHECK_FIELD.equals(strFieldType))
+        {
+            Description description = null;
+            Spec spec = null;
+        	
+        	IXMLElement descriptionElem = field.getFirstChildNamed(DESCRIPTION);
+        	if (descriptionElem != null)
+            {
+                description = new Description(descriptionElem);
+            }
+        	
+        	IXMLElement specElem = field.getFirstChildNamed(SPEC);
+            if (specElem != null) {
+            	spec = new Spec(specElem);
+            }
+        	
+        	return new Check(strVariableName, spec, description);
+        }
+        else if (TITLE_TEXT.equals(strFieldType))
+        {
+            String strText = null;
+            strText = field.getAttribute(TEXT);
+            return new Title(strText);        	
+        } 
+        else if (SPACE_TEXT.equals(strFieldType)) 
+        {
+        	return new Space();
+        }
+        else if (DIVIDER_TEXT.equals(strFieldType))
+        {
+        
+        	return new Divider();
         }
         else
         {
-            System.out.println(strFieldType + " field collection not implemented");
+        	System.out.println(strFieldType + " field collection not implemented");
 
         }
         return null;
     }
 
-    public class Input
-    {
-
-        public Input(String strVariableName, String strDefaultValue, List<Choice> listChoices,
-                String strFieldType, String strText, int iSelectedChoice)
-        {
-            this.strVariableName = strVariableName;
-            this.strDefaultValue = strDefaultValue;
-            this.listChoices = listChoices;
-            this.strFieldType = strFieldType;
-            this.strText = strText;
-            this.iSelectedChoice = iSelectedChoice;
-        }
-
-        String strVariableName;
-
-        String strDefaultValue;
+    
+    abstract class Input {
+    	
+    	protected ConsoleInstallHelper helper 
+    		= ConsoleInstallHelper.getInstance();
+    	
+    	private final String variableName;
+
+    	public String getVariableName() {
+			return variableName;
+		}
+		
+		protected Input(String variableName) {
+    		this.variableName = variableName;
+    	}
+		
+    	abstract boolean process(AutomatedInstallData idata)
+    	throws IOException;
+    
+    	// string input, default is always valid
+    	protected boolean isValid(String value) 
+    	{
+    		return true;
+    	}
+    	
+    	String inputValidValue() throws IOException {
+    		boolean isValidValue = false;
+    		
+            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
+    		while (false == isValidValue) {
+                String strIn = br.readLine();
+                if (isValid(strIn))
+                {
+                	return strIn;
+                } 
+                else 
+                {
+                	System.out.print("Invalid value. Try again: ");
+                }
+    		}
+    		
+    		// should be unreachable in practice
+    		return "";
+    	}
+    	
+    	
+    }
+    
+    public class Text extends Input {
+		private final String strDefaultValue;
+		protected final String text;
+		private final Choice choice;
+		private final boolean doesInput;
+
+		public Text(String variableName, boolean doesInput,
+				String defaultValue, Choice choice, String text) {
+			super(variableName);
+			this.doesInput = doesInput;
+			this.strDefaultValue = defaultValue;
+			this.choice = choice;
+			this.text = text;
+		}
+
+		boolean process(AutomatedInstallData idata) {
+            String variable = getVariableName();
+            String set;
+            String fieldText;
+            if (doesInput)
+            	if ((variable == null) || (variable.length() == 0)) 
+            	{ 
+            		return false; 
+            	}
+
+            set = strDefaultValue;
+            if (set == null)
+            {
+                if (variable != null) {
+                	set = idata.getVariable(variable);
+                }
+                if (set == null)
+                {
+                    set = "";
+                }
+            }
+            else
+            {
+                if (set != null && !"".equals(set))
+                {
+                    VariableSubstitutor vs = new VariableSubstitutor(idata.getVariables());
+                    set = vs.substitute(set, null);
+                }
+            }
 
-        List<Choice> listChoices;
+            fieldText = (choice == null) ? text  : choice.strText;
+            fieldText = helper.variables.expand(fieldText, idata);
+            System.out.print(fieldText);
+            if (doesInput) System.out.print(" [" + set + "] ");
+            System.out.println();
+            
+            if (doesInput) {
+	            try
+	            {
+	                BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
+	                String strIn = br.readLine();
+	                if (!strIn.trim().equals(""))
+	                {
+	                    idata.setVariable(variable, strIn);
+	                }
+	                else
+	                {
+	                    idata.setVariable(variable, set);
+	                }
+	            }
+	            catch (IOException e)
+	            {
+	                e.printStackTrace();
+	            }
+            }
+            return true;
 
-        String strFieldType;
+		}
+    }
+    
+    class Password extends Input {
+
+		private final String pwd1;
+		private final String pwd2;
+
+		protected Password(String variableName, String pwd1, String pwd2) {
+			super(variableName);
+			this.pwd1 = pwd1;
+			this.pwd2 = pwd2;
+		}
+
+		boolean process(AutomatedInstallData idata) throws IOException {
+			
+			String input1 = null;
+			String input2 = null;
+			
+			while (true) {
+				input1 = helper.console.askForPassword(pwd1);
+				input2 = helper.console.askForPassword(pwd2);
+				
+				if (input1 != null && input1.equals(input2)) 
+				{
+					break; // we have two the same non-null passwords
+				} 
+				else 
+				{
+					helper.console.displayMessage("Please enter two " +
+							"non-empty passwords");
+				}
+			}
+			
+            idata.setVariable(getVariableName(), input1);
+			
+			return true;
+		}
+    }
+    
+    class StaticText extends Text {
+    	public StaticText(String strVariableName, String text) {
+    		super(strVariableName, false, null, null, text);
+		}
+    }
 
-        String strText;
+    class Title extends Text {
+    	public Title(String text) {
+			super(null, false, null, null, text);
+		}
 
-        int iSelectedChoice = -1;
+		boolean process(AutomatedInstallData idata) {
+			String expandedTxt = helper.variables.expand(text, idata);
+			System.out.println("*** " + expandedTxt);
+			return true;
+		}
     }
-
-    public class Choice
+    
+    class Space extends Text {
+    	public Space() {
+    		super(null, false, null, null, "");
+    	}
+    }
+    
+    class Divider extends Text {
+    	public Divider() {
+    		super(null, false, null, null, "-------------------");
+    	}
+    }
+    
+    class Combo extends Input{
+    	
+		private final List<Choice> listChoices;
+		private int iSelectedChoice = -1;
+
+		public Combo(String strVariableName, List<Choice> listChoices,
+				String strFieldText) {
+			super(strVariableName);
+			this.listChoices = listChoices;
+		}
+
+		boolean process(AutomatedInstallData idata) {
+			
+			String variable = getVariableName();
+	        if ((variable == null) || (variable.length() == 0)) { return false; }
+	        String currentvariablevalue = idata.getVariable(variable);
+	        boolean userinput = false;
+	        List<Choice> lisChoices = listChoices;
+	        if (lisChoices.size() == 0)
+	        {
+	            Debug.trace("Error: no spec element defined in file field");
+	            return false;
+	        }
+	        if (currentvariablevalue != null)
+	        {
+	            userinput = true;
+	        }
+	        for (int i = 0; i < lisChoices.size(); i++)
+	        {
+	            Choice choice = lisChoices.get(i);
+	            String value = choice.strValue;
+	            if (userinput)
+	            {
+	                if ((value != null) && (value.length() > 0) && (currentvariablevalue.equals(value)))
+	                {
+	                    iSelectedChoice = i;
+	                }
+	            }
+	            else
+	            {
+	                String set = choice.strSet;
+	                if (set != null)
+	                {
+	                    if (set != null && !"".equals(set))
+	                    {
+	                        VariableSubstitutor vs = new VariableSubstitutor(idata.getVariables());
+	                        set = vs.substitute(set, null);
+	                    }
+	                    if (set.equals(TRUE))
+	                    {
+	                        iSelectedChoice = i;
+	                    }
+	                }
+	            }
+	            System.out.println(i + "  [" + (iSelectedChoice == i ? "x" : " ") + "] "
+	                    + (choice.strText != null ? choice.strText : ""));
+	        }
+
+	        try
+	        {
+	            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
+	            boolean bKeepAsking = true;
+
+	            while (bKeepAsking)
+	            {
+	                System.out.println("input selection:");
+	                String strIn = br.readLine();
+	                // take default value if default value exists and no user input
+	                if (strIn.trim().equals("") && iSelectedChoice != -1)
+	                {
+	                    bKeepAsking = false;
+	                }
+	                int j = -1;
+	                try
+	                {
+	                    j = Integer.valueOf(strIn).intValue();
+	                }
+	                catch (Exception ex)
+	                {}
+	                // take user input if user input is valid
+	                if (j >= 0 && j < lisChoices.size())
+	                {
+	                    iSelectedChoice = j;
+	                    bKeepAsking = false;
+	                }
+	            }
+	        }
+	        catch (IOException e)
+	        {
+	            e.printStackTrace();
+	        }
+	        idata.setVariable(variable, listChoices.get(iSelectedChoice).strValue);
+	        return true;
+		}
+    
+    }
+ 
+    class Check extends Input {
+    	private final Spec spec;
+		private final Description description;
+
+		public Check(String strVariableName, Spec spec, Description description) {
+    		super(strVariableName);
+			this.spec = spec;
+			this.description = description;
+    	}
+
+		boolean process(AutomatedInstallData idata) 
+		throws IOException {
+			System.out.println(getInitialPrompt());
+			String input = inputValidValue();
+			idata.setVariable(getVariableName(), input);
+			return true;
+		}
+		
+		private String getInitialPrompt() {
+			List<Object> choices = Arrays.asList(spec.getIsTrue(), spec.getIsFalse());
+			StringBuilder result = new StringBuilder();
+			if (description != null)
+			{
+				result.append(description.getText() + "\n");
+			}
+			result.append(spec.getTxt() + "\n");
+			result.append(formatChoices(choices));
+			return result.toString();
+		}
+		
+		private String formatChoices(Object ...choices) {
+			StringBuilder result = new StringBuilder();
+			for (Object choice : choices) {
+				result.append(choice);
+			}
+			return result.toString();
+		}
+		
+		protected boolean isValid(String input) {
+			return spec.isTrue.equals(input) || spec.isFalse.equals(input);
+		}
+		
+		
+    }
+    
+    class Choice
     {
 
         public Choice(String strText, String strValue, String strSet)
@@ -457,9 +673,59 @@ public class UserInputPanelConsoleHelper extends PanelConsoleHelper implements P
         }
 
         String strText;
-
         String strValue;
-
         String strSet;
+        
+    }
+    
+    class Description {
+
+    	private final String text;
+		private final String id;
+
+		public String getText() {
+			return text;
+		}
+
+		public String getId() {
+			return id;
+		}
+
+		public Description(IXMLElement elem) {
+    		text = elem.getAttribute(TEXT);
+    		id = elem.getAttribute(ID);
+		}
+    }
+    
+    class Spec {
+
+    	private final Object txt;
+		private final Object id;
+		private final Object isTrue;
+		private final Object isFalse;
+		
+		public Object getTxt() {
+			return txt;
+		}
+
+		public Object getId() {
+			return id;
+		}
+
+		public Object getIsTrue() {
+			return isTrue;
+		}
+
+		public Object getIsFalse() {
+			return isFalse;
+		}
+
+		public Spec(IXMLElement spec) {
+			txt = spec.getAttribute(TEXT);
+			id = spec.getAttribute(ID);
+			isTrue = spec.getAttribute(TRUE);
+			isFalse = spec.getAttribute(FALSE);
+        	// set attribute - what for?
+		}
     }
 }
